open BinInt
open BinPos
open Bool
open Datatypes
open Zbool
open Zpower

type spec_float =
| S754_zero of bool
| S754_infinity of bool
| S754_nan
| S754_finite of bool * int * int

(** val emin : int -> int -> int **)

let emin prec emax =
  Z.sub (Z.sub ((fun p->1+2*p) 1) emax) prec

(** val fexp : int -> int -> int -> int **)

let fexp prec emax e =
  Z.max (Z.sub e prec) (emin prec emax)

(** val digits2_pos : int -> int **)

let rec digits2_pos n =
  (fun f2p1 f2p f1 p ->
  if p<=1 then f1 () else if p mod 2 = 0 then f2p (p/2) else f2p1 (p/2))
    (fun p -> Pos.succ (digits2_pos p))
    (fun p -> Pos.succ (digits2_pos p))
    (fun _ -> 1)
    n

(** val coq_Zdigits2 : int -> int **)

let coq_Zdigits2 n =
  (fun f0 fp fn z -> if z=0 then f0 () else if z>0 then fp z else fn (-z))
    (fun _ -> n)
    (fun p -> (digits2_pos p))
    (fun p -> (digits2_pos p))
    n

(** val canonical_mantissa : int -> int -> int -> int -> bool **)

let canonical_mantissa prec emax m e =
  coq_Zeq_bool (fexp prec emax (Z.add (digits2_pos m) e)) e

(** val bounded : int -> int -> int -> int -> bool **)

let bounded prec emax m e =
  (&&) (canonical_mantissa prec emax m e) (Z.leb e (Z.sub emax prec))

(** val valid_binary : int -> int -> spec_float -> bool **)

let valid_binary prec emax = function
| S754_finite (_, m, e) -> bounded prec emax m e
| _ -> true

(** val iter_pos : ('a1 -> 'a1) -> int -> 'a1 -> 'a1 **)

let rec iter_pos f n x =
  (fun f2p1 f2p f1 p ->
  if p<=1 then f1 () else if p mod 2 = 0 then f2p (p/2) else f2p1 (p/2))
    (fun n' -> iter_pos f n' (iter_pos f n' (f x)))
    (fun n' -> iter_pos f n' (iter_pos f n' x))
    (fun _ -> f x)
    n

type location =
| Coq_loc_Exact
| Coq_loc_Inexact of comparison

(** val location_rect : 'a1 -> (comparison -> 'a1) -> location -> 'a1 **)

let location_rect f f0 = function
| Coq_loc_Exact -> f
| Coq_loc_Inexact x -> f0 x

(** val location_rec : 'a1 -> (comparison -> 'a1) -> location -> 'a1 **)

let location_rec f f0 = function
| Coq_loc_Exact -> f
| Coq_loc_Inexact x -> f0 x

type shr_record = { shr_m : int; shr_r : bool; shr_s : bool }

(** val shr_m : shr_record -> int **)

let shr_m s =
  s.shr_m

(** val shr_r : shr_record -> bool **)

let shr_r s =
  s.shr_r

(** val shr_s : shr_record -> bool **)

let shr_s s =
  s.shr_s

(** val shr_1 : shr_record -> shr_record **)

let shr_1 mrs =
  let { shr_m = m; shr_r = r; shr_s = s } = mrs in
  let s0 = (||) r s in
  ((fun f0 fp fn z -> if z=0 then f0 () else if z>0 then fp z else fn (-z))
     (fun _ -> { shr_m = 0; shr_r = false; shr_s = s0 })
     (fun p0 ->
     (fun f2p1 f2p f1 p ->
  if p<=1 then f1 () else if p mod 2 = 0 then f2p (p/2) else f2p1 (p/2))
       (fun p -> { shr_m = p; shr_r = true; shr_s = s0 })
       (fun p -> { shr_m = p; shr_r = false; shr_s = s0 })
       (fun _ -> { shr_m = 0; shr_r = true; shr_s = s0 })
       p0)
     (fun p0 ->
     (fun f2p1 f2p f1 p ->
  if p<=1 then f1 () else if p mod 2 = 0 then f2p (p/2) else f2p1 (p/2))
       (fun p -> { shr_m = ((~-) p); shr_r = true; shr_s = s0 })
       (fun p -> { shr_m = ((~-) p); shr_r = false; shr_s = s0 })
       (fun _ -> { shr_m = 0; shr_r = true; shr_s = s0 })
       p0)
     m)

(** val loc_of_shr_record : shr_record -> location **)

let loc_of_shr_record mrs =
  let { shr_m = _; shr_r = shr_r0; shr_s = shr_s0 } = mrs in
  if shr_r0
  then if shr_s0 then Coq_loc_Inexact Gt else Coq_loc_Inexact Eq
  else if shr_s0 then Coq_loc_Inexact Lt else Coq_loc_Exact

(** val shr_record_of_loc : int -> location -> shr_record **)

let shr_record_of_loc m = function
| Coq_loc_Exact -> { shr_m = m; shr_r = false; shr_s = false }
| Coq_loc_Inexact c ->
  (match c with
   | Eq -> { shr_m = m; shr_r = true; shr_s = false }
   | Lt -> { shr_m = m; shr_r = false; shr_s = true }
   | Gt -> { shr_m = m; shr_r = true; shr_s = true })

(** val shr : shr_record -> int -> int -> shr_record * int **)

let shr mrs e n =
  (fun f0 fp fn z -> if z=0 then f0 () else if z>0 then fp z else fn (-z))
    (fun _ -> (mrs, e))
    (fun p -> ((iter_pos shr_1 p mrs), (Z.add e n)))
    (fun _ -> (mrs, e))
    n

(** val shr_fexp :
    int -> int -> int -> int -> location -> shr_record * int **)

let shr_fexp prec emax m e l =
  shr (shr_record_of_loc m l) e
    (Z.sub (fexp prec emax (Z.add (coq_Zdigits2 m) e)) e)

(** val round_nearest_even : int -> location -> int **)

let round_nearest_even mx = function
| Coq_loc_Exact -> mx
| Coq_loc_Inexact c ->
  (match c with
   | Eq -> if Z.even mx then mx else Z.add mx 1
   | Lt -> mx
   | Gt -> Z.add mx 1)

(** val binary_round_aux :
    int -> int -> bool -> int -> int -> location -> spec_float **)

let binary_round_aux prec emax sx mx ex lx =
  let (mrs', e') = shr_fexp prec emax mx ex lx in
  let (mrs'', e'') =
    shr_fexp prec emax
      (round_nearest_even mrs'.shr_m (loc_of_shr_record mrs')) e'
      Coq_loc_Exact
  in
  ((fun f0 fp fn z -> if z=0 then f0 () else if z>0 then fp z else fn (-z))
     (fun _ -> S754_zero sx)
     (fun m ->
     if Z.leb e'' (Z.sub emax prec)
     then S754_finite (sx, m, e'')
     else S754_infinity sx)
     (fun _ -> S754_nan)
     mrs''.shr_m)

(** val shl_align : int -> int -> int -> int * int **)

let shl_align mx ex ex' =
  (fun f0 fp fn z -> if z=0 then f0 () else if z>0 then fp z else fn (-z))
    (fun _ -> (mx, ex))
    (fun _ -> (mx, ex))
    (fun d -> ((shift_pos d mx), ex'))
    (Z.sub ex' ex)

(** val binary_round : int -> int -> bool -> int -> int -> spec_float **)

let binary_round prec emax sx mx ex =
  let (mz, ez) = shl_align mx ex (fexp prec emax (Z.add (digits2_pos mx) ex))
  in
  binary_round_aux prec emax sx mz ez Coq_loc_Exact

(** val binary_normalize : int -> int -> int -> int -> bool -> spec_float **)

let binary_normalize prec emax m e szero =
  (fun f0 fp fn z -> if z=0 then f0 () else if z>0 then fp z else fn (-z))
    (fun _ -> S754_zero szero)
    (fun m0 -> binary_round prec emax false m0 e)
    (fun m0 -> binary_round prec emax true m0 e)
    m

(** val coq_SFopp : spec_float -> spec_float **)

let coq_SFopp = function
| S754_zero sx -> S754_zero (negb sx)
| S754_infinity sx -> S754_infinity (negb sx)
| S754_nan -> S754_nan
| S754_finite (sx, mx, ex) -> S754_finite ((negb sx), mx, ex)

(** val coq_SFabs : spec_float -> spec_float **)

let coq_SFabs = function
| S754_zero _ -> S754_zero false
| S754_infinity _ -> S754_infinity false
| S754_nan -> S754_nan
| S754_finite (_, mx, ex) -> S754_finite (false, mx, ex)

(** val coq_SFcompare : spec_float -> spec_float -> comparison option **)

let coq_SFcompare f1 f2 =
  match f1 with
  | S754_zero _ ->
    (match f2 with
     | S754_zero _ -> Some Eq
     | S754_infinity s -> Some (if s then Gt else Lt)
     | S754_nan -> None
     | S754_finite (s, _, _) -> Some (if s then Gt else Lt))
  | S754_infinity s ->
    (match f2 with
     | S754_infinity s0 ->
       Some (if s then if s0 then Eq else Lt else if s0 then Gt else Eq)
     | S754_nan -> None
     | _ -> Some (if s then Lt else Gt))
  | S754_nan -> None
  | S754_finite (s1, m1, e1) ->
    (match f2 with
     | S754_zero _ -> Some (if s1 then Lt else Gt)
     | S754_infinity s -> Some (if s then Gt else Lt)
     | S754_nan -> None
     | S754_finite (s2, m2, e2) ->
       Some
         (if s1
          then if s2
               then (match Z.compare e1 e2 with
                     | Eq -> coq_CompOpp (Pos.compare_cont Eq m1 m2)
                     | Lt -> Gt
                     | Gt -> Lt)
               else Lt
          else if s2
               then Gt
               else (match Z.compare e1 e2 with
                     | Eq -> Pos.compare_cont Eq m1 m2
                     | x -> x)))

(** val coq_SFeqb : spec_float -> spec_float -> bool **)

let coq_SFeqb f1 f2 =
  match coq_SFcompare f1 f2 with
  | Some c -> (match c with
               | Eq -> true
               | _ -> false)
  | None -> false

(** val coq_SFltb : spec_float -> spec_float -> bool **)

let coq_SFltb f1 f2 =
  match coq_SFcompare f1 f2 with
  | Some c -> (match c with
               | Lt -> true
               | _ -> false)
  | None -> false

(** val coq_SFleb : spec_float -> spec_float -> bool **)

let coq_SFleb f1 f2 =
  match coq_SFcompare f1 f2 with
  | Some _ -> true
  | None -> false

(** val coq_SFclassify : int -> spec_float -> Float64.float_class **)

let coq_SFclassify prec = function
| S754_zero s -> if s then PZero else NZero
| S754_infinity s -> if s then NInf else PInf
| S754_nan -> NaN
| S754_finite (s, m, _) ->
  if s
  then if Pos.eqb (digits2_pos m) (Z.to_pos prec) then NNormal else NSubn
  else if Pos.eqb (digits2_pos m) (Z.to_pos prec) then PNormal else PSubn

(** val coq_SFmul : int -> int -> spec_float -> spec_float -> spec_float **)

let coq_SFmul prec emax x y =
  match x with
  | S754_zero sx ->
    (match y with
     | S754_zero sy -> S754_zero (xorb sx sy)
     | S754_finite (sy, _, _) -> S754_zero (xorb sx sy)
     | _ -> S754_nan)
  | S754_infinity sx ->
    (match y with
     | S754_infinity sy -> S754_infinity (xorb sx sy)
     | S754_finite (sy, _, _) -> S754_infinity (xorb sx sy)
     | _ -> S754_nan)
  | S754_nan -> S754_nan
  | S754_finite (sx, mx, ex) ->
    (match y with
     | S754_zero sy -> S754_zero (xorb sx sy)
     | S754_infinity sy -> S754_infinity (xorb sx sy)
     | S754_nan -> S754_nan
     | S754_finite (sy, my, ey) ->
       binary_round_aux prec emax (xorb sx sy) (Pos.mul mx my) (Z.add ex ey)
         Coq_loc_Exact)

(** val cond_Zopp : bool -> int -> int **)

let cond_Zopp b m =
  if b then Z.opp m else m

(** val coq_SFadd : int -> int -> spec_float -> spec_float -> spec_float **)

let coq_SFadd prec emax x y =
  match x with
  | S754_zero sx ->
    (match y with
     | S754_zero sy -> if eqb sx sy then x else S754_zero false
     | S754_nan -> S754_nan
     | _ -> y)
  | S754_infinity sx ->
    (match y with
     | S754_infinity sy -> if eqb sx sy then x else S754_nan
     | S754_nan -> S754_nan
     | _ -> x)
  | S754_nan -> S754_nan
  | S754_finite (sx, mx, ex) ->
    (match y with
     | S754_zero _ -> x
     | S754_infinity _ -> y
     | S754_nan -> S754_nan
     | S754_finite (sy, my, ey) ->
       let ez = Z.min ex ey in
       binary_normalize prec emax
         (Z.add (cond_Zopp sx (fst (shl_align mx ex ez)))
           (cond_Zopp sy (fst (shl_align my ey ez)))) ez false)

(** val coq_SFsub : int -> int -> spec_float -> spec_float -> spec_float **)

let coq_SFsub prec emax x y =
  match x with
  | S754_zero sx ->
    (match y with
     | S754_zero sy -> if eqb sx (negb sy) then x else S754_zero false
     | S754_infinity sy -> S754_infinity (negb sy)
     | S754_nan -> S754_nan
     | S754_finite (sy, my, ey) -> S754_finite ((negb sy), my, ey))
  | S754_infinity sx ->
    (match y with
     | S754_infinity sy -> if eqb sx (negb sy) then x else S754_nan
     | S754_nan -> S754_nan
     | _ -> x)
  | S754_nan -> S754_nan
  | S754_finite (sx, mx, ex) ->
    (match y with
     | S754_zero _ -> x
     | S754_infinity sy -> S754_infinity (negb sy)
     | S754_nan -> S754_nan
     | S754_finite (sy, my, ey) ->
       let ez = Z.min ex ey in
       binary_normalize prec emax
         (Z.sub (cond_Zopp sx (fst (shl_align mx ex ez)))
           (cond_Zopp sy (fst (shl_align my ey ez)))) ez false)

(** val new_location_even : int -> int -> location **)

let new_location_even nb_steps k =
  if coq_Zeq_bool k 0
  then Coq_loc_Exact
  else Coq_loc_Inexact (Z.compare (Z.mul ((fun p->2*p) 1) k) nb_steps)

(** val new_location_odd : int -> int -> location **)

let new_location_odd nb_steps k =
  if coq_Zeq_bool k 0
  then Coq_loc_Exact
  else Coq_loc_Inexact
         (match Z.compare (Z.add (Z.mul ((fun p->2*p) 1) k) 1) nb_steps with
          | Eq -> Lt
          | x -> x)

(** val new_location : int -> int -> location **)

let new_location nb_steps =
  if Z.even nb_steps
  then new_location_even nb_steps
  else new_location_odd nb_steps

(** val coq_SFdiv_core_binary :
    int -> int -> int -> int -> int -> int -> (int * int) * location **)

let coq_SFdiv_core_binary prec emax m1 e1 m2 e2 =
  let d1 = coq_Zdigits2 m1 in
  let d2 = coq_Zdigits2 m2 in
  let e' =
    Z.min (fexp prec emax (Z.sub (Z.add d1 e1) (Z.add d2 e2))) (Z.sub e1 e2)
  in
  let s = Z.sub (Z.sub e1 e2) e' in
  let m' =
    (fun f0 fp fn z -> if z=0 then f0 () else if z>0 then fp z else fn (-z))
      (fun _ -> m1)
      (fun _ -> Z.shiftl m1 s)
      (fun _ -> 0)
      s
  in
  let (q, r) = Z.div_eucl m' m2 in ((q, e'), (new_location m2 r))

(** val coq_SFdiv : int -> int -> spec_float -> spec_float -> spec_float **)

let coq_SFdiv prec emax x y =
  match x with
  | S754_zero sx ->
    (match y with
     | S754_infinity sy -> S754_zero (xorb sx sy)
     | S754_finite (sy, _, _) -> S754_zero (xorb sx sy)
     | _ -> S754_nan)
  | S754_infinity sx ->
    (match y with
     | S754_zero sy -> S754_infinity (xorb sx sy)
     | S754_finite (sy, _, _) -> S754_infinity (xorb sx sy)
     | _ -> S754_nan)
  | S754_nan -> S754_nan
  | S754_finite (sx, mx, ex) ->
    (match y with
     | S754_zero sy -> S754_infinity (xorb sx sy)
     | S754_infinity sy -> S754_zero (xorb sx sy)
     | S754_nan -> S754_nan
     | S754_finite (sy, my, ey) ->
       let (p, lz) = coq_SFdiv_core_binary prec emax mx ex my ey in
       let (mz, ez) = p in binary_round_aux prec emax (xorb sx sy) mz ez lz)

(** val coq_SFsqrt_core_binary :
    int -> int -> int -> int -> (int * int) * location **)

let coq_SFsqrt_core_binary prec emax m e =
  let d = coq_Zdigits2 m in
  let e' = Z.min (fexp prec emax (Z.div2 (Z.add (Z.add d e) 1))) (Z.div2 e) in
  let s = Z.sub e (Z.mul ((fun p->2*p) 1) e') in
  let m' =
    (fun f0 fp fn z -> if z=0 then f0 () else if z>0 then fp z else fn (-z))
      (fun _ -> m)
      (fun _ -> Z.shiftl m s)
      (fun _ -> 0)
      s
  in
  let (q, r) = Z.sqrtrem m' in
  let l =
    if coq_Zeq_bool r 0
    then Coq_loc_Exact
    else Coq_loc_Inexact (if Z.leb r q then Lt else Gt)
  in
  ((q, e'), l)

(** val coq_SFsqrt : int -> int -> spec_float -> spec_float **)

let coq_SFsqrt prec emax x = match x with
| S754_zero _ -> x
| S754_infinity s -> if s then S754_nan else x
| S754_nan -> S754_nan
| S754_finite (sx, mx, ex) ->
  if sx
  then S754_nan
  else let (p, lz) = coq_SFsqrt_core_binary prec emax mx ex in
       let (mz, ez) = p in binary_round_aux prec emax false mz ez lz

(** val coq_SFnormfr_mantissa : int -> spec_float -> int **)

let coq_SFnormfr_mantissa prec = function
| S754_finite (_, mx, ex) -> if Z.eqb ex (Z.opp prec) then mx else 0
| _ -> 0

(** val coq_SFldexp : int -> int -> spec_float -> int -> spec_float **)

let coq_SFldexp prec emax f e =
  match f with
  | S754_finite (sx, mx, ex) -> binary_round prec emax sx mx (Z.add ex e)
  | _ -> f

(** val coq_SFfrexp : int -> int -> spec_float -> spec_float * int **)

let coq_SFfrexp prec emax f = match f with
| S754_finite (sx, mx, ex) ->
  if Pos.leb (Z.to_pos prec) (digits2_pos mx)
  then ((S754_finite (sx, mx, (Z.opp prec))), (Z.add ex prec))
  else let d = Z.sub prec (digits2_pos mx) in
       ((S754_finite (sx, (shift_pos (Z.to_pos d) mx), (Z.opp prec))),
       (Z.sub (Z.add ex prec) d))
| _ -> (f, (Z.sub (Z.mul ((~-) ((fun p->2*p) 1)) emax) prec))

(** val coq_SFone : int -> int -> spec_float **)

let coq_SFone prec emax =
  binary_round prec emax false 1 0

(** val coq_SFulp : int -> int -> spec_float -> spec_float **)

let coq_SFulp prec emax x =
  coq_SFldexp prec emax (coq_SFone prec emax)
    (fexp prec emax (snd (coq_SFfrexp prec emax x)))

(** val coq_SFpred_pos : int -> int -> spec_float -> spec_float **)

let coq_SFpred_pos prec emax x = match x with
| S754_finite (_, mx, _) ->
  let d =
    if Pos.eqb ((fun p->2*p) mx) (shift_pos (Z.to_pos prec) 1)
    then coq_SFldexp prec emax (coq_SFone prec emax)
           (fexp prec emax (Z.sub (snd (coq_SFfrexp prec emax x)) 1))
    else coq_SFulp prec emax x
  in
  coq_SFsub prec emax x d
| _ -> x

(** val coq_SFmax_float : int -> int -> spec_float **)

let coq_SFmax_float prec emax =
  S754_finite (false, (Pos.sub (shift_pos (Z.to_pos prec) 1) 1),
    (Z.sub emax prec))

(** val coq_SFsucc : int -> int -> spec_float -> spec_float **)

let coq_SFsucc prec emax x = match x with
| S754_zero _ -> coq_SFldexp prec emax (coq_SFone prec emax) (emin prec emax)
| S754_infinity s -> if s then coq_SFopp (coq_SFmax_float prec emax) else x
| S754_nan -> x
| S754_finite (s, _, _) ->
  if s
  then coq_SFopp (coq_SFpred_pos prec emax (coq_SFopp x))
  else coq_SFadd prec emax x (coq_SFulp prec emax x)

(** val coq_SFpred : int -> int -> spec_float -> spec_float **)

let coq_SFpred prec emax f =
  coq_SFopp (coq_SFsucc prec emax (coq_SFopp f))
