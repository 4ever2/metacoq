(* Distributed under the terms of the MIT license. *)
From Coq Require Import ProofIrrelevance.
From MetaCoq.Template Require Import config utils uGraph.
From MetaCoq.PCUIC Require Import PCUICAst PCUICAstUtils
     PCUICReflect PCUICLiftSubst PCUICUnivSubst PCUICTyping
     PCUICCumulativity PCUICEquality PCUICConversion
     PCUICSafeLemmata PCUICNormal PCUICInversion PCUICReduction PCUICPosition
     PCUICPrincipality PCUICContextConversion PCUICSN PCUICUtils PCUICWeakening
     PCUICConversionInversion.
From MetaCoq.SafeChecker Require Import PCUICSafeReduce.

Require Import Equations.Prop.DepElim.
From Equations Require Import Equations.

Local Set Keyed Unification.

Set Default Goal Selector "!".

Module PSR := PCUICSafeReduce.

(* Removing the definitions generated by equations *)
Add Search Blacklist "obligation".
Add Search Blacklist "equation".
Add Search Blacklist "clause".
Add Search Blacklist "Functional".
Add Search Blacklist "graph".
Add Search Blacklist "elim".
(* Removing the eliminators *)
Add Search Blacklist "ind".
Add Search Blacklist "rec".

(** * Conversion for PCUIC without fuel

  Following PCUICSafereduce, we derive a fuel-free implementation of
  conversion (and cumulativity) checking for PCUIC.

 *)


Definition wf_global_uctx_invariants {cf:checker_flags} Σ :
  ∥ wf Σ ∥ ->
  global_uctx_invariants (global_uctx Σ).
Proof.
  intros [HΣ]. split.
  - cbn. unfold global_levels.
    cut (LevelSet.In Level.lSet (LevelSet_pair Level.lSet Level.lProp)).
    + generalize (LevelSet_pair Level.lSet Level.lProp).
      clear HΣ. induction Σ; simpl. 1: easy.
      intros X H. apply LevelSet.union_spec. now right.
    + apply LevelSet.add_spec. right. now apply LevelSet.singleton_spec.
  - unfold global_uctx.
    simpl. intros [[l ct] l'] Hctr. simpl in *.
    induction Σ in HΣ, l, ct, l', Hctr |- *.
    + apply ConstraintSetFact.empty_iff in Hctr; contradiction.
    + simpl in *. apply ConstraintSet.union_spec in Hctr.
      destruct Hctr as [Hctr|Hctr].
      * split.
        -- inversion HΣ; subst.
           destruct H2 as [HH1 [HH HH3]].
           subst udecl. destruct d as [decl|decl]; simpl in *.
           ++ destruct decl; simpl in *.
              destruct cst_universes ; [
                eapply (HH (l, ct, l') Hctr)
              | apply ConstraintSetFact.empty_iff in Hctr ; contradiction
              ].
           ++ destruct decl. simpl in *.
              destruct ind_universes ; [
                eapply (HH (l, ct, l') Hctr)
              | apply ConstraintSetFact.empty_iff in Hctr; contradiction
              ].
        -- inversion HΣ. subst.
           destruct H2 as [HH1 [HH HH3]].
           subst udecl. destruct d as [decl|decl].
           all: simpl in *.
           ++ destruct decl. simpl in *.
              destruct cst_universes ; [
                eapply (HH (l, ct, l') Hctr)
              | apply ConstraintSetFact.empty_iff in Hctr; contradiction
              ].
           ++ destruct decl. simpl in *.
              destruct ind_universes; [
                eapply (HH (l, ct, l') Hctr)
              | apply ConstraintSetFact.empty_iff in Hctr; contradiction
              ].
      * inversion HΣ. subst.
        split.
        all: apply LevelSet.union_spec.
        all: right.
        all: unshelve eapply (IHΣ _ _ _ _ Hctr).
        all: try eassumption.
Qed.

Definition wf_ext_global_uctx_invariants {cf:checker_flags} Σ :
  ∥ wf_ext Σ ∥ ->
  global_uctx_invariants (global_ext_uctx Σ).
Proof.
  intros [HΣ]. split.
  - apply LevelSet.union_spec. right. unfold global_levels.
    cut (LevelSet.In Level.lSet (LevelSet_pair Level.lSet Level.lProp)).
    + generalize (LevelSet_pair Level.lSet Level.lProp).
      induction Σ.1; simpl. 1: easy.
      intros X H. apply LevelSet.union_spec. now right.
    + apply LevelSet.add_spec. right. now apply LevelSet.singleton_spec.
  - destruct Σ as [Σ φ]. destruct HΣ as [HΣ Hφ].
    destruct (wf_global_uctx_invariants _ (sq HΣ)) as [_ XX].
    unfold global_ext_uctx, global_ext_levels, global_ext_constraints.
    simpl. intros [[l ct] l'] Hctr. simpl in *. apply ConstraintSet.union_spec in Hctr.
    destruct Hctr as [Hctr|Hctr].
    + destruct Hφ as [_ [HH _]]. apply (HH _ Hctr).
    + specialize (XX _ Hctr).
      split; apply LevelSet.union_spec; right; apply XX.
Qed.

Definition global_ext_uctx_consistent {cf:checker_flags} Σ
  : ∥ wf_ext Σ ∥ -> consistent (global_ext_uctx Σ).2.
  intros [HΣ]. cbn. unfold global_ext_constraints.
  unfold wf_ext, on_global_env_ext in HΣ.
  destruct HΣ as [_ [_ [_ HH]]]. apply HH.
Qed.


Section Conversion.

  Context {cf : checker_flags}.
  (* Unused *)
  (* Context (flags : RedFlags.t). *)
  Context (Σ : global_env_ext).
  Context (hΣ : ∥ wf Σ ∥) (Hφ : ∥ on_udecl Σ.1 Σ.2 ∥).
  Context (G : universes_graph) (HG : is_graph_of_uctx G (global_ext_uctx Σ)).

  Local Definition hΣ' : ∥ wf_ext Σ ∥.
  Proof.
    destruct hΣ, Hφ; now constructor.
  Defined.


  Set Equations With UIP.

  Inductive state :=
  | Reduction
  | Term
  | Args
  | Fallback.

  Inductive stateR : state -> state -> Prop :=
  | stateR_Term_Reduction : stateR Term Reduction
  | stateR_Args_Term : stateR Args Term
  | stateR_Fallback_Term : stateR Fallback Term
  | stateR_Args_Fallback : stateR Args Fallback.

  Derive Signature for stateR.

  Lemma stateR_Acc :
    forall s, Acc stateR s.
  Proof.
    assert (Acc stateR Args) as hArgs.
    { constructor. intros s h.
      dependent induction h.
      all: discriminate.
    }
    assert (Acc stateR Fallback) as hFall.
    { constructor. intros s h.
      dependent induction h.
      all: try discriminate.
      apply hArgs.
    }
    assert (Acc stateR Term) as hTerm.
    { constructor. intros s h.
      dependent induction h.
      all: try discriminate.
      - apply hArgs.
      - apply hFall.
    }
    assert (Acc stateR Reduction) as hRed.
    { constructor. intros s h.
      dependent induction h.
      all: try discriminate.
      apply hTerm.
    }
    intro s. destruct s ; eauto.
  Qed.

  Notation wtp Γ t π :=
    (wellformed Σ Γ (zipc t π)) (only parsing).

  Set Primitive Projections.

  Record pack (Γ : context) := mkpack {
    st   : state ;
    tm1  : term ;
    stk1 : stack ;
    tm2  : term ;
    stk2 : stack ;
    wth  : wtp Γ tm2 stk2
  }.

  Arguments st {_} _.
  Arguments tm1 {_} _.
  Arguments stk1 {_} _.
  Arguments tm2 {_} _.
  Arguments stk2 {_} _.
  Arguments wth {_} _.

  Definition wterm Γ := { t : term | wellformed Σ Γ t }.

  Definition wcored Γ (u v : wterm Γ) :=
    cored' Σ Γ (` u) (` v).

  Lemma wcored_wf :
    forall Γ, well_founded (wcored Γ).
  Proof.
    intros Γ [u hu].
    destruct hΣ as [hΣ'].
    apply normalisation_upto in hu as h. 2: assumption.
    dependent induction h.
    constructor. intros [y hy] r.
    unfold wcored in r. cbn in r.
    eapply H0. all: assumption.
  Qed.

  Definition eqt u v :=
    ∥ eq_term Σ Σ u v ∥.

  (* TODO REMOVE? *)
  Lemma eq_term_valid_pos :
    forall {u v p},
      validpos u p ->
      eqt u v ->
      validpos v p.
  Proof.
    intros u v p vp [e].
    eapply eq_term_valid_pos. all: eauto.
  Qed.

  Definition weqt {Γ} (u v : wterm Γ) :=
    eqt (` u) (` v).

  Equations R_aux (Γ : context) :
    (∑ t : term, pos t × (∑ w : wterm Γ, pos (` w) × state)) ->
    (∑ t : term, pos t × (∑ w : wterm Γ, pos (` w) × state)) -> Prop :=
    R_aux Γ :=
      t ⊨ eqt \ cored' Σ Γ by _ ⨷
      @posR t ⊗
      w ⊨ weqt \ wcored Γ by _ ⨷
      @posR (` w) ⊗
      stateR.
  Next Obligation.
    split. 2: intuition eauto.
    exists (` p).
    destruct p as [p hp].
    eapply eq_term_valid_pos. all: eauto.
  Defined.
  Next Obligation.
    split. 2: assumption.
    exists (` p).
    destruct x as [u hu], x' as [v hv].
    destruct p as [p hp].
    simpl in *.
    eapply eq_term_valid_pos. all: eauto.
  Defined.

  Derive Signature for Subterm.lexprod.

  Lemma R_aux_Acc :
    forall Γ t p w q s,
      wellformed Σ Γ t ->
      Acc (R_aux Γ) (t ; (p, (w ; (q, s)))).
  Proof.
    intros Γ t p w q s ht.
    rewrite R_aux_equation_1.
    unshelve eapply dlexmod_Acc.
    - intros x y [e]. constructor. eapply eq_term_sym. assumption.
    - intros x y z [e1] [e2]. constructor. eapply eq_term_trans. all: eauto.
    - intro u. eapply Subterm.wf_lexprod.
      + intro. eapply posR_Acc.
      + intros [w' q'].
        unshelve eapply dlexmod_Acc.
        * intros x y [e]. constructor. eapply eq_term_sym. assumption.
        * intros x y z [e1] [e2]. constructor. eapply eq_term_trans. all: eauto.
        * intros [t' h']. eapply Subterm.wf_lexprod.
          -- intro. eapply posR_Acc.
          -- intro. eapply stateR_Acc.
        * intros x x' y [e] [y' [x'' [r [[e1] [e2]]]]].
          eexists _,_. intuition eauto.
          -- constructor. assumption.
          -- constructor. eapply eq_term_trans. all: eauto.
        * intros x. exists (sq (eq_term_refl _ _ _)). intros [[q'' h] ?].
          unfold R_aux_obligations_obligation_2.
          simpl. f_equal. f_equal.
          eapply uip.
        * intros x x' [[q'' h] ?] [e].
          unfold R_aux_obligations_obligation_2.
          simpl. f_equal. f_equal.
          eapply uip.
        * intros x y z e1 e2 [[q'' h] ?].
          unfold R_aux_obligations_obligation_2.
          simpl. f_equal. f_equal.
          eapply uip.
        * intros [t1 ht1] [t2 ht2] [e] [[q1 hq1] s1] [[q2 hq2] s2] h.
          simpl in *.
          dependent destruction h.
          -- left. unfold posR in *. simpl in *. assumption.
          -- match goal with
             | |- context [ exist q1 ?hq1 ] =>
               assert (ee : hq1 = hq2) by eapply uip
             end.
            rewrite ee. right. clear ee. assumption.
        * eapply wcored_wf.
    - intros x x' y [e] [y' [x'' [r [[e1] [e2]]]]].
      eexists _,_. intuition eauto.
      + constructor. assumption.
      + constructor. eapply eq_term_trans. all: eauto.
    - intros x. exists (sq (eq_term_refl _ _ _)). intros [[q' h] [? [? ?]]].
      unfold R_aux_obligations_obligation_1.
      simpl. f_equal. f_equal.
      eapply uip.
    - intros x x' [[q' h] [? [? ?]]] [e].
      unfold R_aux_obligations_obligation_1.
      simpl. f_equal. f_equal.
      eapply uip.
    - intros x y z e1 e2 [[q' h] [? [? ?]]].
      unfold R_aux_obligations_obligation_1.
      simpl. f_equal. f_equal.
      eapply uip.
    - intros x x' [e]
             [[p1 hp1] [[u hu] [[q1 hq1] s1]]]
             [[p2 hp2] [[v hv] [[q2 hq2] s2]]] hl.
      simpl in *.
      dependent destruction hl.
      + left. unfold posR in *.
        simpl in *.
        assumption.
      + match goal with
        | |- context [ exist p1 ?hp1 ] =>
          assert (ee : hp1 = hp2) by eapply uip
        end.
        rewrite ee. right. clear ee.
        dependent destruction H.
        * left. assumption.
        * unshelve econstructor 2. 1: assumption.
          dependent destruction H.
          -- left. unfold posR in *.
             simpl in *. assumption.
          -- right. assumption.
    - eapply normalisation_upto. all: assumption.
  Qed.

  Notation pzt u := (zipc (tm1 u) (stk1 u)) (only parsing).
  Notation pps1 u := (stack_pos (tm1 u) (stk1 u)) (only parsing).
  Notation pwt u := (exist _ (wth u)) (only parsing).
  Notation pps2 u := (stack_pos (tm2 u) (stk2 u)) (only parsing).

  Notation obpack u :=
    (pzt u ; (pps1 u, (pwt u ; (pps2 u, st u)))) (only parsing).

  Definition R Γ (u v : pack Γ) :=
    R_aux Γ (obpack u) (obpack v).

  Lemma R_Acc :
    forall Γ u,
      wellformed Σ Γ (zipc (tm1 u) (stk1 u)) ->
      Acc (R Γ) u.
  Proof.
    intros Γ u h.
    eapply Acc_fun with (f := fun x => obpack x).
    apply R_aux_Acc. assumption.
  Qed.

  Notation eq_term Σ t u := (eq_term Σ Σ t u).

  Lemma R_cored :
    forall Γ p1 p2,
      cored Σ Γ (pzt p1) (pzt p2) ->
      R Γ p1 p2.
  Proof.
    intros Γ p1 p2 h.
    left. eapply cored_cored'. assumption.
  Qed.

  Lemma R_aux_positionR :
    forall Γ t1 t2 (p1 : pos t1) (p2 : pos t2) s1 s2,
      eq_term Σ t1 t2 ->
      positionR (` p1) (` p2) ->
      R_aux Γ (t1 ; (p1, s1)) (t2 ; (p2, s2)).
  Proof.
    intros Γ t1 t2 p1 p2 [? [? ?]] s2 e h.
    unshelve eright.
    - constructor. assumption.
    - left. unfold posR. simpl. assumption.
  Qed.

  Lemma R_positionR :
    forall Γ p1 p2,
      eq_term Σ (pzt p1) (pzt p2) ->
      positionR (` (pps1 p1)) (` (pps1 p2)) ->
      R Γ p1 p2.
  Proof.
    intros Γ [s1 t1 π1 ρ1 t1' h1] [s2 t2 π2 ρ2 t2' h2] e h. simpl in *.
    eapply R_aux_positionR ; simpl.
    - assumption.
    - assumption.
  Qed.

  Lemma R_aux_cored2 :
    forall Γ t1 t2 (p1 : pos t1) (p2 : pos t2) w1 w2 q1 q2 s1 s2,
      eq_term Σ t1 t2 ->
      ` p1 = ` p2 ->
      cored' Σ Γ (` w1) (` w2) ->
      R_aux Γ (t1 ; (p1, (w1 ; (q1, s1)))) (t2 ; (p2, (w2 ; (q2, s2)))).
  Proof.
    intros Γ t1 t2 [p1 hp1] [p2 hp2] [t1' h1'] [t2' h2'] q1 q2 s1 s2 e1 e2 h.
    cbn in e2. cbn in h. subst.
    unshelve eright.
    - constructor. assumption.
    - unfold R_aux_obligations_obligation_1. simpl.
      match goal with
      | |- context [ exist p2 ?hp1 ] =>
        assert (e : hp1 = hp2) by eapply uip
      end.
      rewrite e.
      right.
      left. assumption.
  Qed.

  Lemma R_cored2 :
    forall Γ p1 p2,
      eq_term Σ (pzt p1) (pzt p2) ->
      ` (pps1 p1) = ` (pps1 p2) ->
      cored Σ Γ (` (pwt p1)) (` (pwt p2)) ->
      R Γ p1 p2.
  Proof.
    intros Γ [s1 t1 π1 ρ1 t1' h1] [s2 t2 π2 ρ2 t2' h2] e1 e2 h. simpl in *.
    eapply R_aux_cored2. all: simpl. all: auto.
    destruct s1, s2.
    all: eapply cored_cored'.
    all: assumption.
  Qed.

  Lemma R_aux_positionR2 :
    forall Γ t1 t2 (p1 : pos t1) (p2 : pos t2) w1 w2 q1 q2 s1 s2,
      eq_term Σ t1 t2 ->
      ` p1 = ` p2 ->
      eq_term Σ (` w1) (` w2) ->
      positionR (` q1) (` q2) ->
      R_aux Γ (t1 ; (p1, (w1 ; (q1, s1)))) (t2 ; (p2, (w2 ; (q2, s2)))).
  Proof.
    intros Γ t1 t2 [p1 hp1] [p2 hp2] [t1' h1'] [t2' h2'] q1 q2 s1 s2 e1 e2 e3 h.
    cbn in e2. cbn in e3. subst.
    unshelve eright.
    - constructor. assumption.
    - unfold R_aux_obligations_obligation_1. simpl.
      match goal with
      | |- context [ exist p2 ?hp1 ] =>
        assert (e : hp1 = hp2) by eapply uip
      end.
      rewrite e.
      right.
      unshelve eright.
      + constructor. assumption.
      + left. unfold posR. simpl. assumption.
  Qed.

  Lemma R_positionR2 :
    forall Γ p1 p2,
      eq_term Σ (pzt p1) (pzt p2) ->
      ` (pps1 p1) = ` (pps1 p2) ->
      eq_term Σ (` (pwt p1)) (` (pwt p2)) ->
      positionR (` (pps2 p1)) (` (pps2 p2)) ->
      R Γ p1 p2.
  Proof.
    intros Γ [s1 t1 π1 ρ1 t1' h1] [s2 t2 π2 ρ2 t2' h2] e1 e2 e3 h.
    simpl in *.
    eapply R_aux_positionR2. all: simpl. all: auto.
  Qed.

  Lemma R_aux_stateR :
    forall Γ t1 t2 (p1 : pos t1) (p2 : pos t2) w1 w2 q1 q2 s1 s2 ,
      eq_term Σ t1 t2 ->
      ` p1 = ` p2 ->
      eq_term Σ (` w1) (` w2) ->
      ` q1 = ` q2 ->
      stateR s1 s2 ->
      R_aux Γ (t1 ; (p1, (w1 ; (q1, s1)))) (t2 ; (p2, (w2 ; (q2, s2)))).
  Proof.
    intros Γ t1 t2 [p1 hp1] [p2 hp2] [t1' h1'] [t2' h2'] [q1 hq1] [q2 hq2] s1 s2
           e1 e2 e3 e4 h.
    cbn in e2. cbn in e3. cbn in e4. subst.
    unshelve eright.
    - constructor. assumption.
    - unfold R_aux_obligations_obligation_1. simpl.
      match goal with
      | |- context [ exist p2 ?hp1 ] =>
        assert (e : hp1 = hp2) by eapply uip
      end.
      rewrite e.
      right.
      unshelve eright.
      + constructor. assumption.
      + unfold R_aux_obligations_obligation_2. simpl.
        match goal with
        | |- context [ exist q2 ?hq1 ] =>
          assert (e' : hq1 = hq2) by eapply uip
        end.
        rewrite e'.
        right. assumption.
  Qed.

  Lemma R_stateR :
    forall Γ p1 p2,
      eq_term Σ (pzt p1) (pzt p2) ->
      ` (pps1 p1) = ` (pps1 p2) ->
      eq_term Σ (` (pwt p1)) (` (pwt p2)) ->
      ` (pps2 p1) = ` (pps2 p2) ->
      stateR (st p1) (st p2) ->
      R Γ p1 p2.
  Proof.
    intros Γ [s1 t1 π1 ρ1 t1' h1] [s2 t2 π2 ρ2 t2' h2] e1 e2 e3 e4 h.
    simpl in *.
    eapply R_aux_stateR. all: simpl. all: auto.
  Qed.
  
  Definition conv_pb_relb pb :=
    match pb with
    | Conv => check_eqb_universe G
    | Cumul => check_leqb_universe G
    end.
  
  Definition eqb_termp_napp pb napp :=
    eqb_term_upto_univ_napp Σ (check_eqb_universe G) (conv_pb_relb pb) napp.
  
  Lemma eqb_termp_napp_spec pb napp t u :
    eqb_termp_napp pb napp t u ->
    eq_termp_napp Σ pb napp t u.
  Proof.
    pose proof hΣ'.
    apply eqb_term_upto_univ_impl.
    - intros u1 u2.
      eapply (check_eqb_universe_spec' G (global_ext_uctx Σ)).
      + now eapply wf_ext_global_uctx_invariants.
      + now eapply global_ext_uctx_consistent.
      + assumption.
    - intros u1 u2.
      destruct pb.
      + eapply (check_eqb_universe_spec' G (global_ext_uctx Σ)).
        * now eapply wf_ext_global_uctx_invariants.
        * now eapply global_ext_uctx_consistent.
        * assumption.
      + eapply (check_leqb_universe_spec' G (global_ext_uctx Σ)).
        * now eapply wf_ext_global_uctx_invariants.
        * now eapply global_ext_uctx_consistent.
        * assumption.
  Qed.
  
  Definition eqb_termp pb := (eqb_termp_napp pb 0).
  Definition eqb_term := (eqb_termp Conv).
  Definition leqb_term := (eqb_termp Cumul).
  
  Lemma leqb_term_spec t u :
    leqb_term t u ->
    leq_term Σ (global_ext_constraints Σ) t u.
  Proof.
    intros.
    now apply eqb_termp_napp_spec in H.
  Qed.
  
  Lemma eqb_term_spec t u :
    eqb_term t u ->
    eq_term Σ t u.
  Proof.
    intros.
    now apply eqb_termp_napp_spec in H.
  Qed.

  Lemma eqb_term_refl :
    forall t, eqb_term t t.
  Proof.
    intro t. eapply eqb_term_upto_univ_refl.
    all: apply check_eqb_universe_refl.
  Qed.

  Fixpoint eqb_ctx (Γ Δ : context) : bool :=
    match Γ, Δ with
    | [], [] => true
    | {| decl_name := na1 ; decl_body := None ; decl_type := t1 |} :: Γ,
      {| decl_name := na2 ; decl_body := None ; decl_type := t2 |} :: Δ =>
      eqb_term t1 t2 && eqb_ctx Γ Δ
    | {| decl_name := na1 ; decl_body := Some b1 ; decl_type := t1 |} :: Γ,
      {| decl_name := na2 ; decl_body := Some b2 ; decl_type := t2 |} :: Δ =>
      eqb_term b1 b2 && eqb_term t1 t2 && eqb_ctx Γ Δ
    | _, _ => false
    end.

  Lemma eqb_ctx_spec :
    forall Γ Δ,
      eqb_ctx Γ Δ ->
      eq_context_upto Σ (eq_universe Σ) Γ Δ.
  Proof.
    intros Γ Δ h.
    induction Γ as [| [na [b|] A] Γ ih ] in Δ, h |- *.
    all: destruct Δ as [| [na' [b'|] A'] Δ].
    all: try discriminate.
    - constructor.
    - simpl in h. apply andP in h as [h h3]. apply andP in h as [h1 h2].
      constructor.
      + eapply eqb_term_spec. assumption.
      + eapply eqb_term_spec. assumption.
      + eapply ih. assumption.
    - simpl in h. apply andP in h as [h1 h2].
      constructor.
      + eapply eqb_term_spec. assumption.
      + eapply ih. assumption.
  Qed.

  Definition eqb_term_stack t1 π1 t2 π2 :=
    eqb_ctx (stack_context π1) (stack_context π2) &&
    eqb_term (zipp t1 π1) (zipp t2 π2).

  Lemma eqb_term_stack_spec :
    forall Γ t1 π1 t2 π2,
      eqb_term_stack t1 π1 t2 π2 ->
      eq_context_upto Σ (eq_universe (global_ext_constraints Σ))
                      (Γ ,,, stack_context π1)
                      (Γ ,,, stack_context π2) ×
      eq_term Σ (zipp t1 π1) (zipp t2 π2).
  Proof.
    intros Γ t1 π1 t2 π2 h.
    apply andP in h as [h1 h2].
    split.
    - eapply eq_context_upto_cat.
      + eapply eq_context_upto_refl. intro. apply eq_universe_refl.
      + eapply eqb_ctx_spec. assumption.
    - eapply eqb_term_spec. assumption.
  Qed.

  Definition leqb_term_stack t1 π1 t2 π2 :=
    eqb_ctx (stack_context π1) (stack_context π2) &&
    leqb_term (zipp t1 π1) (zipp t2 π2).
  
  Lemma leqb_term_stack_spec :
    forall Γ t1 π1 t2 π2,
      leqb_term_stack t1 π1 t2 π2 ->
      eq_context_upto Σ (eq_universe (global_ext_constraints Σ))
                      (Γ ,,, stack_context π1)
                      (Γ ,,, stack_context π2) ×
      leq_term Σ Σ (zipp t1 π1) (zipp t2 π2).
  Proof.
    intros Γ t1 π1 t2 π2 h.
    apply andP in h as [h1 h2].
    split.
    - eapply eq_context_upto_cat.
      + eapply eq_context_upto_refl. intro. apply eq_universe_refl.
      + eapply eqb_ctx_spec. assumption.
    - eapply leqb_term_spec. assumption.
  Qed.

  Notation conv_stack_ctx Γ π1 π2 :=
    (∥ conv_context Σ (Γ ,,, stack_context π1) (Γ ,,, stack_context π2) ∥).

  Notation conv_term leq Γ t π t' π' :=
    (conv_cum leq Σ (Γ ,,, stack_context π) (zipp t π) (zipp t' π'))
      (only parsing).

  Notation alt_conv_term Γ t π t' π' :=
    (∥ Σ ;;; Γ ,,, stack_context π |- zipp t π = zipp t' π' ∥)
      (only parsing).

  Inductive ConversionError :=
  | NotFoundConstants (c1 c2 : kername)

  | NotFoundConstant (c : kername)

  | LambdaNotConvertibleTypes
      (Γ1 : context) (na : name) (A1 t1 : term)
      (Γ2 : context) (na' : name) (A2 t2 : term)
      (e : ConversionError)

  | ProdNotConvertibleDomains
      (Γ1 : context) (na : name) (A1 B1 : term)
      (Γ2 : context) (na' : name) (A2 B2 : term)
      (e : ConversionError)

  | CaseOnDifferentInd
      (Γ1 : context)
      (ind : inductive) (par : nat) (p c : term) (brs : list (nat × term))
      (Γ2 : context)
      (ind' : inductive) (par' : nat) (p' c' : term) (brs' : list (nat × term))

  | CaseBranchNumMismatch
      (ind : inductive) (par : nat)
      (Γ : context) (p c : term) (brs1 : list (nat × term))
      (m : nat) (br : term) (brs2 : list (nat × term))
      (Γ' : context) (p' c' : term) (brs1' : list (nat × term))
      (m' : nat) (br' : term) (brs2' : list (nat × term))

  | DistinctStuckProj
      (Γ : context) (p : projection) (c : term)
      (Γ' : context) (p' : projection) (c' : term)

  | CannotUnfoldFix
      (Γ : context) (mfix : mfixpoint term) (idx : nat)
      (Γ' : context) (mfix' : mfixpoint term) (idx' : nat)

  | FixRargMismatch (idx : nat)
      (Γ : context) (u : def term) (mfix1 mfix2 : mfixpoint term)
      (Γ' : context) (v : def term) (mfix1' mfix2' : mfixpoint term)

  | FixMfixMismatch (idx : nat)
      (Γ : context) (mfix : mfixpoint term)
      (Γ' : context) (mfix' : mfixpoint term)

  | DistinctCoFix
      (Γ : context) (mfix : mfixpoint term) (idx : nat)
      (Γ' : context) (mfix' : mfixpoint term) (idx' : nat)

  | StackHeadError
      (leq : conv_pb)
      (Γ1 : context)
      (t1 : term) (args1 : list term) (u1 : term) (l1 : list term)
      (Γ2 : context)
      (t2 : term) (u2 : term) (l2 : list term)
      (e : ConversionError)

  | StackTailError (leq : conv_pb)
      (Γ1 : context)
      (t1 : term) (args1 : list term) (u1 : term) (l1 : list term)
      (Γ2 : context)
      (t2 : term) (u2 : term) (l2 : list term)
      (e : ConversionError)

  | StackMismatch
      (Γ1 : context) (t1 : term) (args1 l1 : list term)
      (Γ2 : context) (t2 : term) (l2 : list term)

  | HeadMismatch
      (leq : conv_pb)
      (Γ1 : context) (t1 : term)
      (Γ2 : context) (t2 : term).

  Inductive ConversionResult (P : Prop) :=
  | Success (h : P)
  | Error (e : ConversionError) (h : ~P).

  Arguments Success {_} _.
  Arguments Error {_} _.

  Definition isred_full Γ t π :=
    isApp t = false /\
    whnf RedFlags.nodelta Σ (Γ,,, stack_context π) (zipp t π).
  
  Lemma isred_full_nobeta Γ t π :
    isred_full Γ t π ->
    isLambda t ->
    isStackApp π = false.
  Proof.
    intros (?&isr) islam.
    destruct t; cbn in *; try easy.
    unfold zipp in isr.
    destruct π; cbn in *; try easy.
    destruct (decompose_stack π) in isr.
    depelim isr; rewrite mkApps_tApp in *; try solve [solve_discr].
    apply whne_mkApps_inv in H0; [|easy].
    destruct H0 as [|(?&?&?&?&?&?&?&?)]; [|discriminate].
    depelim H0; solve_discr; discriminate.
   Qed.
  
  Lemma decompose_stack_stack_cat π π' :
    decompose_stack (π +++ π') =
    ((decompose_stack π).1 ++
     match (decompose_stack π).2 with
     | ε => (decompose_stack π').1
     | _ => []
     end,
     (decompose_stack π).2 +++
     match (decompose_stack π).2 with
     | ε => (decompose_stack π').2
     | _ => π'
     end).
  Proof.
    induction π in π' |- *; cbn in *; auto.
    - now destruct decompose_stack.
    - rewrite !IHπ.
      now destruct (decompose_stack π).
  Qed.

  Lemma zipp_stack_cat π π' t :
    isStackApp π = false ->
    zipp t (π' +++ π) = zipp t π'.
  Proof.
    intros no_stack_app.
    unfold zipp.
    rewrite decompose_stack_stack_cat.
    destruct (decompose_stack π') eqn:decomp.
    cbn.
    destruct s; try now rewrite app_nil_r.
    now destruct π; cbn in *; rewrite ?app_nil_r.
  Qed.
  
  Lemma zipp_appstack t args π :
    zipp t (appstack args π) = zipp (mkApps t args) π.
  Proof.
    unfold zipp.
    rewrite decompose_stack_appstack.
    rewrite <- mkApps_nested.
    now destruct decompose_stack.
  Qed.

  (* Tailored view for isconv_prog and precondition for fallback case *)
  Equations prog_discr (t1 t2 : term) : Prop :=
    prog_discr (tApp _ _) (tApp _ _) := False ;
    prog_discr (tConst _ _) (tConst _ _) := False ;
    prog_discr (tLambda _ _ _) (tLambda _ _ _) := False ;
    prog_discr (tProd _ _ _) (tProd _ _ _) := False ;
    prog_discr (tCase _ _ _ _) (tCase _ _ _ _) := False ;
    prog_discr (tProj _ _) (tProj _ _) := False ;
    prog_discr (tFix _ _) (tFix _ _) := False ;
    prog_discr (tCoFix _ _) (tCoFix _ _) := False ;
    prog_discr _ _ := True.
  
  (* Note that the arity of this should be the same for all s as otherwise
     the extracted code is not correct *)
  Definition Ret s Γ t π t' π' :=
    forall (leq : conv_pb),
      conv_stack_ctx Γ π π' ->
      match s with
      | Term
      | Fallback => isred_full Γ t π
      | _ => True
      end ->
      match s with
      | Term
      | Fallback => isred_full Γ t' π'
      | _ => True
      end ->
      match s with
      | Fallback => prog_discr t t'
      | _ => True
      end ->
      match s with
      | Reduction
      | Term
      | Fallback => ConversionResult (conv_term leq Γ t π t' π')
      | Args => ConversionResult (∥conv_terms Σ (Γ,,, stack_context π)
                                   (decompose_stack π).1
                                   (decompose_stack π').1∥)
      end.

  Definition Aux s Γ t1 π1 t2 π2 h2 :=
     forall s' t1' π1' t2' π2'
       (h1' : wtp Γ t1' π1')
       (h2' : wtp Γ t2' π2'),
       conv_stack_ctx Γ π1 π2 ->
       R Γ
         (mkpack Γ s' t1' π1' t2' π2' h2')
         (mkpack Γ s t1 π1 t2 π2 h2) ->
       Ret s' Γ t1' π1' t2' π2'.

  Notation yes := (Success _) (only parsing).
  Notation no := (fun e => Error e _) (only parsing).

  (* TODO NOTE
     repack could also take another argument of type
     ConversionError -> ConversionError
     to keep a full error trace (we currently only do it partially).
  *)
  Notation repack e :=
    (match e with Success h => Success _ | Error er h => Error er _ end)
    (only parsing).

  Notation isconv_red_raw leq t1 π1 t2 π2 aux :=
    (aux Reduction t1 π1 t2 π2 _ _ _ _ leq _ I I I) (only parsing).
  Notation isconv_prog_raw leq t1 π1 t2 π2 aux :=
    (aux Term t1 π1 t2 π2 _ _ _ _ leq _ _ _ I) (only parsing).
  Notation isconv_args_raw leq t1 π1 t2 π2 aux :=
    (aux Args t1 π1 t2 π2 _ _ _ _ leq _ I I I) (only parsing).
  Notation isconv_fallback_raw leq t1 π1 t2 π2 aux :=
    (aux Fallback t1 π1 t2 π2 _ _ _ _ leq _ _ _ _) (only parsing).

  Notation isconv_red leq t1 π1 t2 π2 aux :=
    (repack (isconv_red_raw leq t1 π1 t2 π2 aux)) (only parsing).
  Notation isconv_prog leq t1 π1 t2 π2 aux :=
    (repack (isconv_prog_raw leq t1 π1 t2 π2 aux)) (only parsing).
  Notation isconv_args leq t1 π1 t2 π2 aux :=
    (repack (isconv_args_raw leq t1 π1 t2 π2 aux)) (only parsing).
  Notation isconv_fallback leq t1 π1 t2 π2 aux :=
    (repack (isconv_fallback_raw leq t1 π1 t2 π2 aux)) (only parsing).

  Equations(noeqns) _isconv_red (Γ : context) (leq : conv_pb)
            (t1 : term) (π1 : stack) (h1 : wtp Γ t1 π1)
            (t2 : term) (π2 : stack) (h2 : wtp Γ t2 π2)
            (hx : conv_stack_ctx Γ π1 π2)
            (aux : Aux Reduction Γ t1 π1 t2 π2 h2)
    : ConversionResult (conv_term leq Γ t1 π1 t2 π2) :=

    _isconv_red Γ leq t1 π1 h1 t2 π2 h2 hx aux
    with inspect (decompose_stack π1) := {
    | @exist (args1, ρ1) e1 with inspect (decompose_stack π2) := {
      | @exist (args2, ρ2) e2
        with inspect (reduce_stack RedFlags.nodelta Σ hΣ (Γ ,,, stack_context π1) t1 (appstack args1 ε) _) := {
        | @exist (t1',π1') eq1
          with inspect (reduce_stack RedFlags.nodelta Σ hΣ (Γ ,,, stack_context π2) t2 (appstack args2 ε) _) := {
          | @exist (t2',π2') eq2 => isconv_prog leq t1' (π1' +++ ρ1) t2' (π2' +++ ρ2) aux
          }
        }
      }
    }.
  Next Obligation.
    symmetry in e1.
    eapply wellformed_zipc_stack_context. all: eassumption.
  Qed.
  Next Obligation.
    clear aux eq1.
    symmetry in e2.
    eapply wellformed_zipc_stack_context. all: eassumption.
  Qed.
  Next Obligation.
    pose proof hΣ as hΣ'.
    destruct hΣ' as [wΣ].
    match type of eq1 with
    | _ = reduce_stack ?f ?Σ ?hΣ ?Γ ?t ?π ?h =>
      destruct (reduce_stack_sound f Σ hΣ Γ t π h) as [r1] ;
      pose proof (reduce_stack_decompose RedFlags.nodelta _ hΣ _ _ _ h) as d1 ;
      pose proof (reduce_stack_context f Σ hΣ Γ t π h) as c1
    end.
    rewrite <- eq1 in r1.
    rewrite <- eq1 in d1. cbn in d1.
    rewrite <- eq1 in c1. cbn in c1.
    rewrite stack_context_appstack in c1. cbn in c1.

    pose proof (decompose_stack_eq _ _ _ (eq_sym e1)). subst.
    clear eq1 eq2.
    rewrite zipc_appstack in h1.
    case_eq (decompose_stack π1'). intros args1' ρ1' e1'.
    rewrite e1' in d1. cbn in d1.
    rewrite decompose_stack_appstack in d1. cbn in d1. subst.
    pose proof (decompose_stack_eq _ _ _ e1'). subst.
    rewrite stack_cat_appstack.
    rewrite zipc_appstack.

    rewrite stack_context_appstack in r1. cbn in r1.
    rewrite 2!zipc_appstack in r1. cbn in r1.

    eapply red_wellformed ; try assumption ; revgoals.
    - constructor. zip fold. eapply red_context. eassumption.
    - cbn. assumption.
  Qed.
  Next Obligation.
    pose proof hΣ as hΣ'.
    destruct hΣ' as [wΣ].
    match type of eq2 with
    | _ = reduce_stack ?f ?Σ ?hΣ ?Γ ?t ?π ?h =>
      destruct (reduce_stack_sound f Σ hΣ Γ t π h) as [r2] ;
      pose proof (reduce_stack_decompose RedFlags.nodelta _ hΣ _ _ _ h) as d2 ;
      pose proof (reduce_stack_context f Σ hΣ Γ t π h) as c2
    end.
    rewrite <- eq2 in r2.
    rewrite <- eq2 in d2. cbn in d2.
    rewrite <- eq2 in c2. cbn in c2.
    rewrite stack_context_appstack in c2. cbn in c2.

    pose proof (decompose_stack_eq _ _ _ (eq_sym e2)). subst.
    clear eq1 eq2 aux.
    rewrite zipc_appstack in h2.
    case_eq (decompose_stack π2'). intros args2' ρ2' e2'.
    rewrite e2' in d2. cbn in d2.
    rewrite decompose_stack_appstack in d2. cbn in d2. subst.
    pose proof (decompose_stack_eq _ _ _ e2'). subst.
    rewrite stack_cat_appstack.
    rewrite zipc_appstack.

    rewrite stack_context_appstack in r2. cbn in r2.
    rewrite 2!zipc_appstack in r2. cbn in r2.

    eapply red_wellformed ; try assumption ; revgoals.
    - constructor. zip fold. eapply red_context. eassumption.
    - cbn. assumption.
  Qed.
  Next Obligation.
    match type of eq1 with
    | _ = reduce_stack ?f ?Σ ?hΣ ?Γ ?t ?π ?h =>
      pose proof (reduce_stack_decompose RedFlags.nodelta _ hΣ _ _ _ h) as d1 ;
      pose proof (reduce_stack_context f Σ hΣ Γ t π h) as c1
    end.
    rewrite <- eq1 in d1. cbn in d1.
    rewrite <- eq1 in c1. cbn in c1.
    rewrite stack_context_appstack in c1. cbn in c1.
    pose proof (decompose_stack_eq _ _ _ (eq_sym e1)). subst.
    match type of eq1 with
    | _ = reduce_stack ?f ?Σ ?hΣ ?Γ ?t ?π ?hh =>
      pose proof (reduce_stack_Req f _ hΣ _ _ _ hh) as [ e | h ]
    end.
    - assert (ee1 := eq1). rewrite e in ee1. inversion ee1. subst.
      match type of eq2 with
      | _ = reduce_stack ?f ?Σ ?hΣ ?Γ ?t ?π ?h =>
        pose proof (reduce_stack_decompose RedFlags.nodelta _ hΣ _ _ _ h) as d2 ;
        pose proof (reduce_stack_context f Σ hΣ Γ t π h) as c2
      end.
      rewrite <- eq2 in d2. cbn in d2.
      rewrite <- eq2 in c2. cbn in c2.
      rewrite stack_context_appstack in c2. cbn in c2.
      pose proof (decompose_stack_eq _ _ _ (eq_sym e2)). subst.
      match type of eq2 with
      | _ = reduce_stack ?f ?Σ ?hΣ ?Γ ?t ?π ?hh =>
        pose proof (reduce_stack_Req f _ hΣ _ _ _ hh) as [ ee | h ]
      end.
      + assert (ee2 := eq2). rewrite ee in ee2. inversion ee2. subst.
        unshelve eapply R_stateR.
        * simpl. rewrite stack_cat_appstack. reflexivity.
        * simpl. rewrite stack_cat_appstack. reflexivity.
        * simpl. rewrite stack_cat_appstack. reflexivity.
        * simpl. rewrite stack_cat_appstack. reflexivity.
        * simpl. constructor.
      + rewrite <- eq2 in h.
        rewrite stack_context_appstack in h.
        dependent destruction h.
        * cbn in H. rewrite zipc_appstack in H. cbn in H.
          unshelve eapply R_cored2.
          -- simpl. rewrite stack_cat_appstack. reflexivity.
          -- simpl. rewrite stack_cat_appstack. reflexivity.
          -- simpl.
             rewrite zipc_appstack. rewrite zipc_stack_cat.
             repeat zip fold. eapply cored_context.
             assumption.
        * destruct y' as [q hq].
          cbn in H0. inversion H0. subst.
          unshelve eapply R_positionR2.
          -- simpl. rewrite stack_cat_appstack. reflexivity.
          -- simpl. rewrite stack_cat_appstack. reflexivity.
          -- simpl. f_equal.
             rewrite zipc_stack_cat.
             rewrite <- H2.
             rewrite 2!zipc_appstack. cbn. reflexivity.
          -- simpl.
             unfold posR in H. cbn in H.
             rewrite stack_position_appstack in H. cbn in H.
             rewrite stack_position_stack_cat.
             rewrite stack_position_appstack.
             eapply positionR_poscat.
             assumption.
    - rewrite <- eq1 in h.
      rewrite stack_context_appstack in h.
      dependent destruction h.
      + cbn in H. rewrite zipc_appstack in H. cbn in H.
        eapply R_cored. simpl.
        rewrite zipc_appstack. rewrite zipc_stack_cat.
        repeat zip fold. eapply cored_context.
        assumption.
      + destruct y' as [q hq].
        cbn in H0. inversion H0. (* Why is noconf failing at this point? *)
        subst.
        unshelve eapply R_positionR ; simpl.
        * f_equal.
          rewrite zipc_stack_cat.
          rewrite <- H2.
          rewrite 2!zipc_appstack. cbn. reflexivity.
        * unfold posR in H. cbn in H.
          rewrite stack_position_appstack in H. cbn in H.
          rewrite stack_position_stack_cat.
          rewrite stack_position_appstack.
          eapply positionR_poscat.
          assumption.
  Qed.
  Next Obligation.
    match type of eq1 with
    | _ = reduce_stack ?f ?Σ ?hΣ ?Γ ?t ?π ?h =>
      pose proof (reduce_stack_decompose RedFlags.nodelta _ hΣ _ _ _ h) as d1 ;
      pose proof (reduce_stack_context f Σ hΣ Γ t π h) as c1
    end.
    rewrite <- eq1 in d1. cbn in d1.
    rewrite <- eq1 in c1. cbn in c1.
    rewrite stack_context_appstack in c1. cbn in c1.
    pose proof (decompose_stack_eq _ _ _ (eq_sym e1)). subst.
    match type of eq2 with
    | _ = reduce_stack ?f ?Σ ?hΣ ?Γ ?t ?π ?h =>
      pose proof (reduce_stack_decompose RedFlags.nodelta _ hΣ _ _ _ h) as d2 ;
      pose proof (reduce_stack_context f Σ hΣ Γ t π h) as c2
    end.
    rewrite <- eq2 in d2. cbn in d2.
    rewrite <- eq2 in c2. cbn in c2.
    rewrite stack_context_appstack in c2. cbn in c2.
    pose proof (decompose_stack_eq _ _ _ (eq_sym e2)). subst.
    rewrite 2!stack_context_stack_cat.
    rewrite c1. rewrite c2. simpl.
    rewrite 2!stack_context_appstack in hx.
    assumption.
  Qed.
  Next Obligation.
    match type of eq1 with
    | _ = reduce_stack ?f ?Σ ?hΣ ?Γ ?t ?π ?h =>
      pose proof (reduce_stack_isred f Σ hΣ Γ t π h eq_refl) as r1;
      pose proof (reduce_stack_whnf f Σ hΣ Γ t π h) as w1
    end.
    rewrite <- eq1 in r1, w1.
    destruct r1 as (ha&hl).
    split; [easy|].
    rewrite stack_context_stack_cat.
    apply (f_equal (snd ∘ decompose_stack ∘ snd)) in eq1.
    rewrite reduce_stack_decompose, decompose_stack_appstack in eq1.
    cbn in eq1.
    rewrite <- (stack_context_decompose π1'), eq1 in *.
    rewrite <- (stack_context_decompose π1), <- e1 in w1.
    cbn in w1 |- *.
    rewrite zipp_stack_cat.
    2: eapply decompose_stack_noStackApp; eauto.
    auto.
  Qed.
  Next Obligation.
    match type of eq2 with
    | _ = reduce_stack ?f ?Σ ?hΣ ?Γ ?t ?π ?h =>
      pose proof (reduce_stack_isred f Σ hΣ Γ t π h eq_refl) as r2;
      pose proof (reduce_stack_whnf f Σ hΣ Γ t π h) as w2
    end.
    rewrite <- eq2 in r2, w2.
    destruct r2 as (ha&hl).
    split; [easy|].
    rewrite stack_context_stack_cat.
    apply (f_equal (snd ∘ decompose_stack ∘ snd)) in eq2.
    rewrite reduce_stack_decompose, decompose_stack_appstack in eq2.
    cbn in eq2.
    rewrite <- (stack_context_decompose π2'), eq2 in *.
    rewrite <- (stack_context_decompose π2), <- e2 in w2.
    cbn in w2 |- *.
    rewrite zipp_stack_cat.
    2: eapply decompose_stack_noStackApp; eauto.
    auto.
  Qed.
  Next Obligation.
    destruct hΣ as [wΣ].
    unfold zipp. rewrite <- e1. rewrite <- e2.

    match type of eq1 with
    | _ = reduce_stack ?f ?Σ ?hΣ ?Γ ?t ?π ?h =>
      destruct (reduce_stack_sound f Σ hΣ Γ t π h) as [r1] ;
      pose proof (reduce_stack_decompose RedFlags.nodelta _ hΣ _ _ _ h) as d1 ;
      pose proof (reduce_stack_context f Σ hΣ Γ t π h) as c1
    end.
    rewrite <- eq1 in r1.
    rewrite <- eq1 in d1. cbn in d1.
    rewrite <- eq1 in c1. cbn in c1.
    rewrite stack_context_appstack in c1. cbn in c1.

    match type of eq2 with
    | _ = reduce_stack ?f ?Σ ?hΣ ?Γ ?t ?π ?h =>
      destruct (reduce_stack_sound f Σ hΣ Γ t π h) as [r2] ;
      pose proof (reduce_stack_decompose RedFlags.nodelta _ hΣ _ _ _ h) as d2 ;
      pose proof (reduce_stack_context f Σ hΣ Γ t π h) as c2
    end.
    rewrite <- eq2 in r2.
    rewrite <- eq2 in d2. cbn in d2.
    rewrite <- eq2 in c2. cbn in c2.
    rewrite stack_context_appstack in c2. cbn in c2.

    clear eq1 eq2.

    pose proof (decompose_stack_eq _ _ _ (eq_sym e1)). subst.
    case_eq (decompose_stack π1'). intros args1' ρ1' e1'.
    rewrite e1' in d1. cbn in d1.
    rewrite decompose_stack_appstack in d1. cbn in d1. subst.
    pose proof (decompose_stack_eq _ _ _ e1'). subst.

    pose proof (decompose_stack_eq _ _ _ (eq_sym e2)). subst.
    case_eq (decompose_stack π2'). intros args2' ρ2' e2'.
    rewrite e2' in d2. cbn in d2.
    rewrite decompose_stack_appstack in d2. cbn in d2. subst.
    pose proof (decompose_stack_eq _ _ _ e2'). subst.

    rewrite stack_context_appstack in r1. cbn in r1.
    rewrite 2!zipc_appstack in r1. cbn in r1.

    rewrite stack_context_appstack in r2. cbn in r2.
    rewrite 2!zipc_appstack in r2. cbn in r2.

    rewrite 2!stack_cat_appstack in h.
    unfold zipp in h.
    rewrite 2!decompose_stack_appstack in h.
    rewrite decompose_stack_twice with (1 := eq_sym e1) in h.
    rewrite decompose_stack_twice with (1 := eq_sym e2) in h.
    simpl in h.
    rewrite 2!app_nil_r in h.
    rewrite 2!stack_context_appstack in hx.
    rewrite stack_context_appstack in h.

    rewrite stack_context_appstack.

    destruct hx as [hx].
    etransitivity.
    - eapply red_conv_cum_l; eassumption.
    - etransitivity.
      + eassumption.
      + eapply conv_cum_context_convp.
        * assumption.
        * eapply red_conv_cum_r. all: eauto.
        * eapply conv_context_sym. all: auto.
  Qed.
  Next Obligation.
    rename H into e; apply h; clear h.

    (* FIXME: the script below is essentially a copy-paste of the previous obligation
      with only the hypothesis and the goal swapped... *)
    destruct hΣ as [wΣ].
    unfold zipp in e. rewrite <- e1, <- e2 in e.

    match type of eq1 with
    | _ = reduce_stack ?f ?Σ ?hΣ ?Γ ?t ?π ?h =>
      destruct (reduce_stack_sound f Σ hΣ Γ t π h) as [r1] ;
      pose proof (reduce_stack_decompose RedFlags.nodelta _ hΣ _ _ _ h) as d1 ;
      pose proof (reduce_stack_context f Σ hΣ Γ t π h) as c1
    end.
    rewrite <- eq1 in r1.
    rewrite <- eq1 in d1. cbn in d1.
    rewrite <- eq1 in c1. cbn in c1.
    rewrite stack_context_appstack in c1. cbn in c1.

    match type of eq2 with
    | _ = reduce_stack ?f ?Σ ?hΣ ?Γ ?t ?π ?h =>
      destruct (reduce_stack_sound f Σ hΣ Γ t π h) as [r2] ;
      pose proof (reduce_stack_decompose RedFlags.nodelta _ hΣ _ _ _ h) as d2 ;
      pose proof (reduce_stack_context f Σ hΣ Γ t π h) as c2
    end.
    rewrite <- eq2 in r2.
    rewrite <- eq2 in d2. cbn in d2.
    rewrite <- eq2 in c2. cbn in c2.
    rewrite stack_context_appstack in c2. cbn in c2.

    clear eq1 eq2.

    pose proof (decompose_stack_eq _ _ _ (eq_sym e1)). subst.
    case_eq (decompose_stack π1'). intros args1' ρ1' e1'.
    rewrite e1' in d1. cbn in d1.
    rewrite decompose_stack_appstack in d1. cbn in d1. subst.
    pose proof (decompose_stack_eq _ _ _ e1'). subst.

    pose proof (decompose_stack_eq _ _ _ (eq_sym e2)). subst.
    case_eq (decompose_stack π2'). intros args2' ρ2' e2'.
    rewrite e2' in d2. cbn in d2.
    rewrite decompose_stack_appstack in d2. cbn in d2. subst.
    pose proof (decompose_stack_eq _ _ _ e2'). subst.

    rewrite stack_context_appstack in r1. cbn in r1.
    rewrite 2!zipc_appstack in r1. cbn in r1.

    rewrite stack_context_appstack in r2. cbn in r2.
    rewrite 2!zipc_appstack in r2. cbn in r2.

    rewrite 2!stack_cat_appstack.
    unfold zipp.
    rewrite 2!decompose_stack_appstack.
    rewrite decompose_stack_twice with (1 := eq_sym e1).
    rewrite decompose_stack_twice with (1 := eq_sym e2).
    simpl.
    rewrite 2!app_nil_r.
    rewrite 2!stack_context_appstack in hx.
    rewrite stack_context_appstack.

    rewrite stack_context_appstack in e.

    destruct hx as [hx].
    etransitivity.
    - eapply red_conv_cum_r; eassumption.
    - etransitivity.
      + eassumption.
      + eapply conv_cum_context_convp.
        * assumption.
        * eapply red_conv_cum_l. all: eauto.
        * eapply conv_context_sym. all: auto.
  Qed.

  Opaque reduce_stack.
  Equations unfold_one_fix (Γ : context) (mfix : mfixpoint term)
            (idx : nat) (π : stack) (h : wtp Γ (tFix mfix idx) π)
    : option (term * stack) :=

    unfold_one_fix Γ mfix idx π h with inspect (unfold_fix mfix idx) := {
    | @exist (Some (arg, fn)) eq1 with inspect (decompose_stack_at π arg) := {
      | @exist (Some (l, c, θ)) eq2 with inspect (reduce_stack RedFlags.default Σ hΣ (Γ ,,, stack_context θ) c ε _) := {
        | @exist (cred, ρ) eq3 with construct_viewc cred := {
          | view_construct ind n ui := Some (fn, appstack l (App (zipc (tConstruct ind n ui) ρ) θ)) ;
          | view_other t h := None
          }
        } ;
      | _ := None
      } ;
    | _ := None
    }.
  Next Obligation.
    destruct hΣ.
    cbn. symmetry in eq2.
    pose proof (decompose_stack_at_eq _ _ _ _ _ eq2). subst.
    rewrite zipc_appstack in h. cbn in h.
    zip fold in h. apply wellformed_context in h ; auto. simpl in h.
    destruct h as [[T h]|[[ctx [s [h1 _]]]]]; [|discriminate].
    apply inversion_App in h as hh ; auto.
    destruct hh as [na [A' [B' [? [? ?]]]]].
    left. eexists. eassumption.
  Qed.
  Transparent reduce_stack.

  Derive NoConfusion NoConfusionHom for option.

  Lemma unfold_one_fix_red_zipp :
    forall Γ mfix idx π h fn ξ,
      Some (fn, ξ) = unfold_one_fix Γ mfix idx π h ->
      ∥ red (fst Σ) (Γ ,,, stack_context π) (zipp (tFix mfix idx) π) (zipp fn ξ) ∥.
  Proof.
    intros Γ mfix idx π h fn ξ eq.
    revert eq.
    funelim (unfold_one_fix Γ mfix idx π h).
    all: intro eq ; noconf eq.
    unfold zipp.
    pose proof (eq_sym e0) as eq.
    pose proof (decompose_stack_at_eq _ _ _ _ _ eq). subst.
    rewrite 2!decompose_stack_appstack. simpl.
    case_eq (decompose_stack s). intros l' s' e'.
    simpl.
    match type of e1 with
    | _ = reduce_stack ?flags ?Σ ?hΣ ?Γ ?t ?π ?h =>
      pose proof (reduce_stack_sound flags Σ hΣ Γ t π h) as [r1] ;
      pose proof (reduce_stack_decompose flags Σ hΣ Γ t π h) as hd
    end.
    rewrite <- e1 in r1. cbn in r1.
    rewrite <- e1 in hd. cbn in hd.
    constructor.
    rewrite stack_context_appstack. simpl.
    rewrite <- 2!mkApps_nested. cbn. eapply red_mkApps_f.
    pose proof (decompose_stack_eq _ _ _ e'). subst.
    rewrite stack_context_appstack in r1.
    rewrite stack_context_appstack.
    eapply trans_red.
    - eapply red_app_r. exact r1.
    - repeat lazymatch goal with
      | |- context [ tApp (mkApps ?t ?l) ?u ] =>
        replace (tApp (mkApps t l) u) with (mkApps t (l ++ [u]))
          by (rewrite <- mkApps_nested ; reflexivity)
      end.
      eapply red_fix.
      + symmetry. eassumption.
      + unfold is_constructor.
        pose proof (eq_sym e0) as eql.
        apply decompose_stack_at_length in eql. subst.
        rewrite nth_error_app_ge by auto.
        replace (#|l| - #|l|) with 0 by lia. cbn.
        case_eq (decompose_stack s0). intros l0 s1 ee.
        rewrite ee in hd.
        pose proof (decompose_stack_eq _ _ _ ee). subst.
        cbn in hd. subst.
        rewrite zipc_appstack. cbn.
        unfold isConstruct_app. rewrite decompose_app_mkApps by auto.
        reflexivity.
  Qed.

  Lemma unfold_one_fix_red_zippx :
    forall Γ mfix idx π h fn ξ,
      Some (fn, ξ) = unfold_one_fix Γ mfix idx π h ->
      ∥ red (fst Σ) Γ (zippx (tFix mfix idx) π) (zippx fn ξ) ∥.
  Proof.
    intros Γ mfix idx π h fn ξ eq.
    revert eq.
    funelim (unfold_one_fix Γ mfix idx π h).
    all: intro eq ; noconf eq.
    unfold zippx.
    pose proof (eq_sym e0) as eq.
    pose proof (decompose_stack_at_eq _ _ _ _ _ eq). subst.
    rewrite 2!decompose_stack_appstack. simpl.
    case_eq (decompose_stack s). intros l' s' e'.
    simpl.
    match type of e1 with
    | _ = reduce_stack ?flags ?Σ ?hΣ ?Γ ?t ?π ?h =>
      pose proof (reduce_stack_sound flags Σ hΣ Γ t π h) as [r1] ;
      pose proof (reduce_stack_decompose flags Σ hΣ Γ t π h) as hd
    end.
    rewrite <- e1 in r1. cbn in r1.
    rewrite <- e1 in hd. cbn in hd.
    constructor. eapply red_it_mkLambda_or_LetIn.
    rewrite <- 2!mkApps_nested. cbn. eapply red_mkApps_f.
    pose proof (decompose_stack_eq _ _ _ e'). subst.
    rewrite stack_context_appstack in r1.
    eapply trans_red.
    - eapply red_app_r. exact r1.
    - repeat lazymatch goal with
      | |- context [ tApp (mkApps ?t ?l) ?u ] =>
        replace (tApp (mkApps t l) u) with (mkApps t (l ++ [u]))
          by (rewrite <- mkApps_nested ; reflexivity)
      end.
      eapply red_fix.
      + symmetry. eassumption.
      + unfold is_constructor.
        pose proof (eq_sym e0) as eql.
        apply decompose_stack_at_length in eql. subst.
        rewrite nth_error_app_ge by auto.
        replace (#|l| - #|l|) with 0 by lia. cbn.
        case_eq (decompose_stack s0). intros l0 s1 ee.
        rewrite ee in hd.
        pose proof (decompose_stack_eq _ _ _ ee). subst.
        cbn in hd. subst.
        rewrite zipc_appstack. cbn.
        unfold isConstruct_app. rewrite decompose_app_mkApps by auto.
        reflexivity.
  Qed.

  Lemma unfold_one_fix_red :
    forall Γ mfix idx π h fn ξ,
      Some (fn, ξ) = unfold_one_fix Γ mfix idx π h ->
      ∥ red (fst Σ) Γ (zipc (tFix mfix idx) π) (zipc fn ξ) ∥.
  Proof.
    intros Γ mfix idx π h fn ξ eq.
    revert eq.
    funelim (unfold_one_fix Γ mfix idx π h).
    all: intro eq ; noconf eq.
    pose proof (eq_sym e0) as eq.
    pose proof (decompose_stack_at_eq _ _ _ _ _ eq). subst.
    rewrite !zipc_appstack. cbn.
    match type of e1 with
    | _ = reduce_stack ?flags ?Σ ?hΣ ?Γ ?t ?π ?h =>
      pose proof (reduce_stack_sound flags Σ hΣ Γ t π h) as [r1] ;
      pose proof (reduce_stack_decompose flags Σ hΣ Γ t π h) as hd
    end.
    rewrite <- e1 in r1. cbn in r1.
    rewrite <- e1 in hd. cbn in hd.
    do 2 zip fold. constructor. eapply red_context.
    eapply trans_red.
    - eapply red_app_r. exact r1.
    - repeat lazymatch goal with
      | |- context [ tApp (mkApps ?t ?l) ?u ] =>
        replace (tApp (mkApps t l) u) with (mkApps t (l ++ [u]))
          by (rewrite <- mkApps_nested ; reflexivity)
      end.
      eapply red_fix.
      + symmetry. eassumption.
      + unfold is_constructor.
        pose proof (eq_sym e0) as eql.
        apply decompose_stack_at_length in eql. subst.
        rewrite nth_error_app_ge by auto.
        replace (#|l| - #|l|) with 0 by lia. cbn.
        case_eq (decompose_stack s0). intros l0 s1 ee.
        rewrite ee in hd.
        pose proof (decompose_stack_eq _ _ _ ee). subst.
        cbn in hd. subst.
        rewrite zipc_appstack. cbn.
        unfold isConstruct_app. rewrite decompose_app_mkApps by auto.
        reflexivity.
  Qed.

  Lemma unfold_one_fix_cored :
    forall Γ mfix idx π h fn ξ,
      Some (fn, ξ) = unfold_one_fix Γ mfix idx π h ->
      cored (fst Σ) Γ (zipc fn ξ) (zipc (tFix mfix idx) π).
  Proof.
    intros Γ mfix idx π h fn ξ eq.
    revert eq.
    funelim (unfold_one_fix Γ mfix idx π h).
    all: intro eq ; noconf eq.
    pose proof (eq_sym e0) as eq.
    pose proof (decompose_stack_at_eq _ _ _ _ _ eq). subst.
    rewrite !zipc_appstack. cbn.
    match type of e1 with
    | _ = reduce_stack ?flags ?Σ ?hΣ ?Γ ?t ?π ?h =>
      pose proof (reduce_stack_sound flags Σ hΣ Γ t π h) as [r1] ;
      pose proof (reduce_stack_decompose flags Σ hΣ Γ t π h) as hd
    end.
    rewrite <- e1 in r1. cbn in r1.
    rewrite <- e1 in hd. cbn in hd.
    do 2 zip fold. eapply cored_context.
    eapply cored_red_trans.
    - eapply red_app_r. exact r1.
    - repeat lazymatch goal with
      | |- context [ tApp (mkApps ?t ?l) ?u ] =>
        replace (tApp (mkApps t l) u) with (mkApps t (l ++ [u]))
          by (rewrite <- mkApps_nested ; reflexivity)
      end.
      eapply red_fix.
      + symmetry. eassumption.
      + unfold is_constructor.
        pose proof (eq_sym e0) as eql.
        apply decompose_stack_at_length in eql. subst.
        rewrite nth_error_app_ge by auto.
        replace (#|l| - #|l|) with 0 by lia. cbn.
        case_eq (decompose_stack s0). intros l0 s1 ee.
        rewrite ee in hd.
        pose proof (decompose_stack_eq _ _ _ ee). subst.
        cbn in hd. subst.
        rewrite zipc_appstack. cbn.
        unfold isConstruct_app. rewrite decompose_app_mkApps by auto.
        reflexivity.
  Qed.

  Lemma unfold_one_fix_decompose :
    forall Γ mfix idx π h fn ξ,
      Some (fn, ξ) = unfold_one_fix Γ mfix idx π h ->
      snd (decompose_stack π) = snd (decompose_stack ξ).
  Proof.
    intros Γ mfix idx π h fn ξ eq.
    revert eq.
    funelim (unfold_one_fix Γ mfix idx π h).
    all: intro eq ; noconf eq.
    pose proof (eq_sym e0) as eq.
    pose proof (decompose_stack_at_eq _ _ _ _ _ eq). subst.
    rewrite 2!decompose_stack_appstack. cbn.
    case_eq (decompose_stack s). intros l0 s1 H2.
    reflexivity.
  Qed.

  Lemma zipp_as_mkApps t π :
    zipp t π = mkApps t (decompose_stack π).1.
  Proof.
    unfold zipp.
    now destruct decompose_stack.
  Qed.

  Lemma unfold_one_fix_None Γ mfix idx π wf : 
    None = unfold_one_fix Γ mfix idx π wf ->
    ∥∑args,
      All2 (red Σ (Γ,,, stack_context π)) (decompose_stack π).1 args ×
      whnf RedFlags.default Σ (Γ,,, stack_context π) (mkApps (tFix mfix idx) args)∥.
  Proof.
    funelim (unfold_one_fix Γ mfix idx π wf).
    all: intros [=].
    - constructor; eexists _; split; [apply All2_same; reflexivity|].
      eapply whnf_fixapp.
      now rewrite <- e.
    - constructor; eexists _; split; [apply All2_same; reflexivity|].
      eapply whnf_fixapp.
      rewrite <- e.
      destruct (decompose_stack π) eqn:decomp.
      apply decompose_stack_noStackApp in decomp as ?.
      apply decompose_stack_eq in decomp as ->.
      clear H.
      symmetry in e0.
      now apply decompose_stack_at_appstack_None in e0.
    - match type of e1 with
      | _ = reduce_stack ?a ?b ?c ?d ?e ?f ?g =>
        pose proof (reduce_stack_sound a b c d e f g) as [r];
        pose proof (reduce_stack_whnf a b c d e f g) as wh;
        pose proof (reduce_stack_decompose a b c d e f g) as decomp;
        pose proof (reduce_stack_isred a b c d e f g) as isr
      end.
      rewrite <- e1 in r, wh, decomp, isr.
      specialize (isr eq_refl) as (noapp&_).
      cbn in *.
      clear H e1 H0.
      symmetry in e0.
      apply decompose_stack_at_length in e0 as ?.
      apply decompose_stack_at_eq in e0 as ->.
      rewrite stack_context_appstack.
      cbn.
      apply wellformed_zipc_zipp in h; auto.
      rewrite <- (stack_context_decompose s0), decomp in wh.
      change (App t0 s) with (appstack [t0] s) in *.
      rewrite !decompose_stack_appstack.
      rewrite zipp_as_mkApps, !decompose_stack_appstack in h.
      destruct h as [(ty&typ)|[(?&?&dar&?)]]; cycle 1.
      { cbn in dar. rewrite destArity_tFix in dar; congruence. }
      cbn in *.
      rewrite stack_context_appstack in typ.
      cbn in *.
      destruct (decompose_stack s0) eqn:decomp'.
      apply decompose_stack_eq in decomp' as ->.
      rewrite zipc_appstack in r.
      rewrite zipp_appstack in wh.
      cbn in *; subst; cbn in *.
      destruct hΣ.
      constructor; exists (l ++ (mkApps t2 l0) :: (decompose_stack s).1).
      eapply PCUICSR.subject_reduction in typ.
      2: eauto.
      2: apply red_mkApps; [reflexivity|].
      1: split.
      1,3: apply All2_app; [apply All2_same; reflexivity|].
      1,2: constructor; [|apply All2_same; reflexivity].
      1-2: eassumption.
      apply whnf_ne.
      econstructor.
      + eauto.
      + rewrite nth_error_snoc by easy.
        eauto.
      + eapply whnf_fix_arg_whne; eauto.
        now destruct t2.
  Qed.

  Inductive prog_view : term -> term -> Type :=
  | prog_view_App u1 v1 u2 v2 :
      prog_view (tApp u1 v1) (tApp u2 v2)

  | prog_view_Const c1 u1 c2 u2 :
      prog_view (tConst c1 u1) (tConst c2 u2)

  | prog_view_Lambda na1 A1 b1 na2 A2 b2 :
      prog_view (tLambda na1 A1 b1) (tLambda na2 A2 b2)

  | prog_view_Prod na1 A1 B1 na2 A2 B2 :
      prog_view (tProd na1 A1 B1) (tProd na2 A2 B2)

  | prog_view_Case ind par p c brs ind' par' p' c' brs' :
      prog_view (tCase (ind, par) p c brs) (tCase (ind', par') p' c' brs')

  | prog_view_Proj p c p' c' :
      prog_view (tProj p c) (tProj p' c')

  | prog_view_Fix mfix idx mfix' idx' :
      prog_view (tFix mfix idx) (tFix mfix' idx')

  | prog_view_CoFix mfix idx mfix' idx' :
      prog_view (tCoFix mfix idx) (tCoFix mfix' idx')

  | prog_view_other :
      forall u v, prog_discr u v -> prog_view u v.

  Equations prog_viewc u v : prog_view u v :=
    prog_viewc (tApp u1 v1) (tApp u2 v2) :=
      prog_view_App u1 v1 u2 v2 ;

    prog_viewc (tConst c1 u1) (tConst c2 u2) :=
      prog_view_Const c1 u1 c2 u2 ;

    prog_viewc (tLambda na1 A1 b1) (tLambda na2 A2 b2) :=
      prog_view_Lambda na1 A1 b1 na2 A2 b2 ;

    prog_viewc (tProd na1 A1 B1) (tProd na2 A2 B2) :=
      prog_view_Prod na1 A1 B1 na2 A2 B2 ;

    prog_viewc (tCase (ind, par) p c brs) (tCase (ind', par') p' c' brs') :=
      prog_view_Case ind par p c brs ind' par' p' c' brs' ;

    prog_viewc (tProj p c) (tProj p' c') :=
      prog_view_Proj p c p' c' ;

    prog_viewc (tFix mfix idx) (tFix mfix' idx') :=
      prog_view_Fix mfix idx mfix' idx' ;

    prog_viewc (tCoFix mfix idx) (tCoFix mfix' idx') :=
      prog_view_CoFix mfix idx mfix' idx' ;

    prog_viewc u v := prog_view_other u v I.

  Lemma elimT (P : Type) (b : bool) : reflectT P b -> b -> P.
  Proof.
    intros []; auto. discriminate.
  Defined.

  Lemma introT (P : Type) (b : bool) : reflectT P b -> P -> b.
  Proof.
    intros []; auto.
  Defined.

  Lemma wellformed_wf_local Γ t :
    wellformed Σ Γ t ->
    ∥ wf_local Σ Γ ∥.
  Proof.
    intros [].
    - destruct hΣ. destruct H.
      now constructor ; eapply typing_wf_local in X0.
    - destruct H, hΣ. constructor. red in X.
      destruct X as [ctx [s [eq wf]]].
      now eapply All_local_env_app in wf.
  Qed.

  (* TODO MOVE *)
  Definition eqb_universe_instance u v :=
    forallb2 (check_eqb_universe G) (map Universe.make u) (map Universe.make v).

  (* TODO MOVE *)
  Lemma eqb_universe_instance_spec :
    forall u v,
      eqb_universe_instance u v ->
      R_universe_instance (eq_universe (global_ext_constraints Σ)) u v.
  Proof.
    intros u v e.
    unfold eqb_universe_instance in e.
    eapply forallb2_Forall2 in e.
    eapply Forall2_impl. 1: eassumption.
    intros. eapply (check_eqb_universe_spec' G (global_ext_uctx Σ)).
    all: auto.
    + eapply wf_ext_global_uctx_invariants.
      eapply hΣ'.
    + eapply global_ext_uctx_consistent.
      eapply hΣ'.
  Qed.

  Lemma mem_level_declared_level x :
    LevelSet.mem x (global_ext_levels Σ) ->
    UnivExprSet.For_all
      (fun e =>
         on_Some_or_None (fun l => LevelSet.In (NoPropLevel.to_level l) (global_ext_uctx Σ).1)
                         (UnivExpr.get_noprop e)) (Universe.make x).
  Proof.
    intros mem ? ->%UnivExprSet.singleton_spec.
    destruct (UnivExpr.get_noprop (UnivExpr.make x)) eqn:np; [|easy].
    cbn.
    replace x with (NoPropLevel.to_level t) in *.
    2: { destruct x; cbn in *; try easy.
         all: now inv np. }
    unfold global_ext_levels in *.
    now apply LevelSet.mem_spec in mem.
  Qed.
  
  Lemma conv_pb_rel_spec leq x y :
    LevelSet.mem x (global_ext_levels Σ) ->
    LevelSet.mem y (global_ext_levels Σ) ->
    conv_pb_rel leq (global_ext_constraints Σ) (Universe.make x) (Universe.make y) ->
    conv_pb_relb leq (Universe.make x) (Universe.make y).
  Proof.
    intros memx memy r.
    destruct leq.
    - eapply eq_universe_spec'; eauto.
      + eapply wf_ext_global_uctx_invariants.
        eapply hΣ'.
      + eapply global_ext_uctx_consistent.
        eapply hΣ'.
      + now apply mem_level_declared_level.
      + now apply mem_level_declared_level.
    - eapply leq_universe_spec'; eauto.
      + eapply wf_ext_global_uctx_invariants.
        eapply hΣ'.
      + eapply global_ext_uctx_consistent.
        eapply hΣ'.
      + now apply mem_level_declared_level.
      + now apply mem_level_declared_level.
  Qed.
  
  Lemma R_universe_instance_spec u u' :
    Forall (fun u => LevelSet.mem u (global_ext_levels Σ)) u ->
    Forall (fun u => LevelSet.mem u (global_ext_levels Σ)) u' ->
    R_universe_instance (eq_universe (global_ext_constraints Σ)) u u' ->
    eqb_universe_instance u u'.
  Proof.
    intros memu memu' r.
    induction u in u', memu, memu', r |- *.
    - now destruct u'.
    - destruct u'; [easy|].
      depelim memu.
      depelim memu'.
      depelim r.
      cbn in *.
      apply Bool.andb_true_iff.
      split.
      + apply (conv_pb_rel_spec Conv); auto.
      + now apply IHu.
  Qed.

  Lemma R_universe_variance_spec leq v u u' :
    LevelSet.mem u (global_ext_levels Σ) ->
    LevelSet.mem u' (global_ext_levels Σ) ->
    R_universe_variance (eq_universe Σ) (conv_pb_rel leq Σ) v u u' ->
    compare_universe_variance (check_eqb_universe G) (conv_pb_relb leq) v u u'.
  Proof.
    intros memu memu' r.
    destruct v; cbn in *; auto.
    - apply conv_pb_rel_spec; auto.
    - apply (conv_pb_rel_spec Conv); auto.
  Qed.

  Lemma R_universe_instance_variance_spec leq v u u' :
    Forall (fun u => LevelSet.mem u (global_ext_levels Σ)) u ->
    Forall (fun u => LevelSet.mem u (global_ext_levels Σ)) u' ->
    R_universe_instance_variance (eq_universe Σ) (conv_pb_rel leq Σ) v u u' ->
    compare_universe_instance_variance (check_eqb_universe G) (conv_pb_relb leq) v u u'.
  Proof.
    intros memu memu' r.
    induction u in v, u', memu, memu', r |- *.
    - now destruct u'.
    - destruct u'; [easy|].
      depelim memu.
      depelim memu'.
      cbn in *.
      destruct v; auto.
      apply Bool.andb_true_iff.
      destruct r.
      split.
      + apply R_universe_variance_spec; auto.
      + now apply IHu.
  Qed.

  Lemma R_global_instance_spec u v leq gr napp :
    Forall (fun u => LevelSet.mem u (global_ext_levels Σ)) u ->
    Forall (fun u => LevelSet.mem u (global_ext_levels Σ)) v->
    R_global_instance Σ (eq_universe Σ) (conv_pb_rel leq Σ) gr napp u v ->
    compare_global_instance Σ (check_eqb_universe G) (conv_pb_relb leq) gr napp u v.
  Proof.
    intros consu consv r.
    unfold compare_global_instance, R_global_instance, R_opt_variance in *.
    destruct global_variance.
    - apply R_universe_instance_variance_spec; auto.
    - apply R_universe_instance_spec; auto.
  Qed.
  
  Lemma consistent_instance_ext_all_mem udecl u :
    consistent_instance_ext Σ udecl u ->
    Forall (fun u => LevelSet.mem u (global_ext_levels Σ)) u.
  Proof.
    intros cons.
    unfold consistent_instance_ext, consistent_instance in *.
    destruct udecl; [now destruct u|].
    destruct cons as (_&mems&_).
    now apply forallb_Forall.
  Qed.
  
  Lemma wellformed_nonarity Γ t :
    destArity [] t = None ->
    wellformed Σ Γ t ->
    welltyped Σ Γ t.
  Proof.
    now intros dar [|[(?&?&?&?)]].
  Qed.
  
  Lemma wellformed_nonarity_mkApps Γ hd args :
    destArity [] hd = None ->
    wellformed Σ Γ (mkApps hd args) ->
    welltyped Σ Γ (mkApps hd args).
  Proof.
    intros dar wf.
    destruct wf as [|[(?&?&dar'&?)]]; auto.
    exfalso.
    clear -dar dar'.
    induction args in args, hd, dar, dar' |- *.
    - cbn in *.
      congruence.
    - cbn in *.
      now apply IHargs in dar'; [|easy].
  Qed.

  Lemma wellformed_zipc_tConst_inv Γ c u π :
    wellformed Σ Γ (zipc (tConst c u) π) ->
    exists cst,
      declared_constant Σ c cst
      × consistent_instance_ext Σ (cst_universes cst) u.
  Proof.
    intros h.
    destruct hΣ.
    zip fold in h.
    apply wellformed_context in h; auto.
    apply wellformed_nonarity in h; auto.
    destruct h as (?&typ).
    apply inversion_Const in typ as (?&?&?&wfu&_); auto.
    now unfold declared_constant in d.
  Qed.
  
  Equations(noeqns) unfold_constants (Γ : context) (leq : conv_pb)
            (c : kername) (u : Instance.t) (π1 : stack)
            (h1 : wtp Γ (tConst c u) π1)
            (c' : kername) (u' : Instance.t) (π2 : stack)
            (h2 : wtp Γ (tConst c' u') π2)
            (ne : c <> c' \/ (c = c' /\ ~eqb_universe_instance u u'))
            (hx : conv_stack_ctx Γ π1 π2)
            (aux : Aux Term Γ (tConst c u) π1 (tConst c' u') π2 h2)
    : ConversionResult (conv_term leq Γ (tConst c u) π1 (tConst c' u') π2) :=

    unfold_constants Γ leq c u π1 h1 c' u' π2 h2 ne hx aux
    with inspect (lookup_env Σ c') := {
    | @exist (Some (ConstantDecl {| cst_body := Some b |})) eq1 :=
      isconv_red leq (tConst c u) π1 (subst_instance_constr u' b) π2 aux ;
    (* Inductive or not found *)
    | _ with inspect (lookup_env Σ c) := {
      | @exist (Some (ConstantDecl {| cst_body := Some b |})) eq2 :=
        isconv_red leq (subst_instance_constr u b) π1
                        (tConst c' u') π2 aux ;
      (* Both Inductive or not found *)
      | _ := Error (NotFoundConstants c c') _
      }
    }.
  Solve All Obligations with
      Tactics.program_simplify;
      CoreTactics.equations_simpl;
      try solve
          [match goal with
           | [H: wellformed ?Σ ?Γ ?t |- _] =>
             let id := fresh in
             apply wellformed_zipc_tConst_inv in H as id;
               destruct id as (?&?&?);
               unfold declared_constant in *;
               congruence
           end].
  Next Obligation.
    eapply red_wellformed ; auto.
    - exact h2.
    - constructor. eapply red_zipc.
      eapply red_const. eassumption.
  Qed.
  Next Obligation.
    unshelve eapply R_cored2.
    all: try reflexivity.
    simpl. eapply cored_zipc.
    eapply cored_const. eassumption.
  Qed.
  Next Obligation.
    destruct hΣ.
    etransitivity ; try eassumption.
    eapply red_conv_cum_r ; try assumption.
    eapply red_zipp. eapply red_const. eassumption.
  Qed.
  Next Obligation.
    (* Contraposition of previous goal *)
    apply h; clear h.
    destruct hΣ.
    etransitivity ; try eassumption.
    eapply red_conv_cum_l ; try assumption.
    eapply red_zipp. eapply red_const. eassumption.
  Qed.
  Next Obligation.
    eapply red_wellformed ; auto ; [ exact h1 | ].
    constructor. eapply red_zipc.
    eapply red_const. eassumption.
  Qed.
  Next Obligation.
    eapply R_cored. simpl. eapply cored_zipc.
    eapply cored_const. eassumption.
  Qed.
  Next Obligation.
    destruct hΣ as [wΣ].
    etransitivity ; try eassumption.
    eapply red_conv_cum_l ; try assumption.
    eapply red_zipp. eapply red_const. eassumption.
  Qed.
  Next Obligation.
    (* Contraposition of previous goal *)
    apply h; clear h.
    destruct hΣ as [wΣ].
    etransitivity ; try eassumption.
    eapply red_conv_cum_r ; try assumption.
    eapply red_zipp. eapply red_const. eassumption.
  Qed.
  Next Obligation.
    (* Both c and c' are axioms. Either they are different constants or they are not
       convertible because the universes are different. *)
    apply conv_cum_alt in H as [(?&?&(r1&r2)&e)].
    rewrite zipp_as_mkApps in r1, r2.
    destruct hΣ.
    symmetry in e0, unknown3.
    eapply PCUICConfluence.red_mkApps_tConst_axiom in r1 as (?&->&?); eauto.
    eapply PCUICConfluence.red_mkApps_tConst_axiom in r2 as (?&->&?); eauto.
    apply eq_termp_mkApps_inv in e as (?&?); [|easy|easy].
    depelim e.
    destruct ne as [|(_&ne)]; [congruence|].
    
    clear aux.
    apply wellformed_zipc_tConst_inv in h1 as (cst1&decl1&cons1).
    apply wellformed_zipc_tConst_inv in h2 as (cst2&decl2&cons2).
    eapply PCUICWeakeningEnv.declared_constant_inj in decl1; eauto; subst.
    apply consistent_instance_ext_all_mem in cons1.
    apply consistent_instance_ext_all_mem in cons2.
    eapply R_universe_instance_spec in r; auto.
  Qed.
    
  (* TODO (RE)MOVE *)
  Lemma destArity_eq_term_upto_univ :
    forall Re Rle Γ1 Γ2 t1 t2 Δ1 s1,
      eq_term_upto_univ Σ Re Rle t1 t2 ->
      eq_context_upto Σ Re Γ1 Γ2 ->
      destArity Γ1 t1 = Some (Δ1, s1) ->
      exists Δ2 s2,
        destArity Γ2 t2 = Some (Δ2, s2) /\
        ∥ eq_context_upto Σ Re Δ1 Δ2 ∥ /\
        Rle s1 s2.
  Proof.
    intros Re Rle Γ1 Γ2 t1 t2 Δ1 s1 ht hΓ e.
    induction ht in Γ1, Γ2, Δ1, s1, hΓ, e |- *.
    all: try discriminate e.
    - simpl in *. inversion e. subst.
      eexists _,_. intuition eauto.
      constructor. assumption.
    - simpl in *.
      eapply IHht2 in e as h.
      + eassumption.
      + constructor. all: auto.
    - simpl in *.
      eapply IHht3 in e as h.
      + eassumption.
      + constructor. all: assumption.
  Qed.

  Lemma wellformed_zipc_tCase_brs_length Γ p motive discr brs π :
    wellformed Σ Γ (zipc (tCase p motive discr brs) π) ->
    exists mib oib, declared_inductive Σ mib p.1 oib /\ #|brs| = #|ind_ctors oib|.
  Proof.
    intros wf.
    zip fold in wf.
    apply wellformed_context in wf; [|assumption].
    apply wellformed_nonarity in wf as (?&typ); [|easy].
    destruct hΣ.
    apply inversion_Case in typ as (?&?&?&?&?&?&?&?&?&?&?&?&?&?&?&?&?); auto.
    exists x1, x2.
    split; [easy|].
    apply All2_length in a as ->.
    apply map_option_out_length in e2.
    rewrite PCUICElimination.length_of_btys in e2.
    congruence.
  Qed.

  Equations isconv_branches (Γ : context)
    (ind : inductive) (par : nat)
    (p c : term) (brs1 brs2 : list (nat × term))
    (π : stack) (h : wtp Γ (tCase (ind, par) p c (brs1 ++ brs2)) π)
    (p' c' : term) (brs1' brs2' : list (nat × term))
    (π' : stack) (h' : wtp Γ (tCase (ind, par) p' c' (brs1' ++ brs2')) π')
    (hx : conv_stack_ctx Γ π π')
    (h1 : ∥ All2 (fun u v => u.1 = v.1 × Σ ;;; Γ ,,, stack_context π |- u.2 = v.2) brs1 brs1' ∥)
    (aux : Aux Term Γ (tCase (ind, par) p c (brs1 ++ brs2)) π (tCase (ind, par) p' c' (brs1' ++ brs2')) π' h')
    : ConversionResult (∥ All2 (fun u v => u.1 = v.1 × Σ ;;; Γ ,,, stack_context π |- u.2 = v.2) brs2 brs2' ∥)
    by struct brs2 :=

    isconv_branches Γ ind par
      p c brs1 ((m, br) :: brs2) π h
      p' c' brs1' ((m', br') :: brs2') π' h' hx h1 aux
    with inspect (eqb m m') := {
    | @exist true eq1
      with isconv_red_raw Conv
              br (Case_brs (ind, par) p c m brs1 brs2 π)
              br' (Case_brs (ind, par) p' c' m' brs1' brs2' π')
      aux := {
      | Success h2
        with isconv_branches Γ ind par
              p c (brs1 ++ [(m,br)]) brs2 π _
              p' c' (brs1' ++ [(m', br')]) brs2' π' _ hx _ _ := {
        | Success h3 := yes ;
        | Error e h := no e
        } ;
      | Error e h := no e
      } ;
    | @exist false eq1 := Error (
        CaseBranchNumMismatch ind par
          (Γ ,,, stack_context π) p c brs1 m br brs2
          (Γ ,,, stack_context π') p' c' brs1' m' br' brs2'
      ) _
    } ;

    isconv_branches Γ ind par
      p c brs1 [] π h
      p' c' brs1' [] π' h' hx h1 aux := yes ;

    isconv_branches Γ ind par
      p c brs1 brs2 π h
      p' c' brs1' brs2' π' h' hx h1 aux := False_rect _ _.
  Next Obligation.
    constructor. constructor.
  Qed.
  Next Obligation.
    destruct h1 as [h1].
    apply All2_length in h1 as e1.
    clear aux.
    apply wellformed_zipc_tCase_brs_length in h as (?&?&?&?).
    apply wellformed_zipc_tCase_brs_length in h' as (?&?&?&?).
    pose proof (PCUICInductiveInversion.declared_inductive_unique_sig H H1) as u; noconf u.
    rewrite app_length in *.
    cbn in *.
    lia.
  Qed.
  Next Obligation.
    destruct h1 as [h1].
    apply All2_length in h1 as e1.
    clear aux.
    apply wellformed_zipc_tCase_brs_length in h as (?&?&?&?).
    apply wellformed_zipc_tCase_brs_length in h' as (?&?&?&?).
    pose proof (PCUICInductiveInversion.declared_inductive_unique_sig H H1) as u; noconf u.
    rewrite app_length in *.
    cbn in *.
    lia.
  Qed.
  Next Obligation.
    eapply R_positionR. all: simpl.
    1: reflexivity.
    rewrite <- app_nil_r. eapply positionR_poscat.
    constructor.
  Qed.
  Next Obligation.
    rewrite <- app_assoc. simpl. assumption.
  Qed.
  Next Obligation.
    rewrite <- app_assoc. simpl. assumption.
  Qed.
  Next Obligation.
    destruct h1 as [h1], h2 as [h2].
    constructor. apply All2_app.
    - assumption.
    - constructor. 2: constructor.
      simpl.
      change (m =? m') with (eqb m m') in eq1.
      destruct (eqb_spec m m'). 2: discriminate.
      intuition eauto.
  Qed.
  Next Obligation.
    unshelve eapply aux. all: try eassumption.
    clear aux.
    lazymatch goal with
    | h : R _ _ ?r1 |- R _ _ ?r2 =>
      assert (e : r1 = r2)
    end.
    { clear H0.
      match goal with
      | |- {| wth := ?x |} = _ =>
        generalize x
      end.
      rewrite <- !app_assoc. simpl.
      intro w.
      f_equal.
      eapply proof_irrelevance.
    }
    rewrite <- e. assumption.
  Qed.
  Next Obligation.
    destruct h1 as [h1], h2 as [h2], h3 as [h3].
    change (m =? m') with (eqb m m') in eq1.
    destruct (eqb_spec m m'). 2: discriminate.
    constructor. constructor. all: intuition eauto.
  Qed.
  Next Obligation.
    (* COntrapositive of previous obligation *)
    apply h; clear h.
    destruct H as [H]; inversion H; now constructor.
  Qed.
  Next Obligation.
    (* Contrapositive of 3rd obligation above *)
    apply h; clear h.
    destruct h1 as [h1], H as [h2].
    constructor. inversion h2; clear h2.
    destruct X as [_ h2]. apply h2.
  Qed.
  Next Obligation.
    destruct H as [H]; inversion H.
    destruct X as [eq_mm' _].
    change (m =? m') with (eqb m m') in eq1.
    destruct (eqb_spec m m') as [|F]. 1: discriminate.
    apply F, eq_mm'.
  Qed.


  Equations isconv_branches' (Γ : context)
    (ind : inductive) (par : nat)
    (p c : term) (brs : list (nat × term))
    (π : stack) (h : wtp Γ (tCase (ind, par) p c brs) π)
    (ind' : inductive) (par' : nat)
    (p' c' : term) (brs' : list (nat × term))
    (π' : stack) (h' : wtp Γ (tCase (ind', par') p' c' brs') π')
    (hx : conv_stack_ctx Γ π π')
    (ei : ind = ind') (ep : par = par')
    (aux : Aux Term Γ (tCase (ind, par) p c brs) π (tCase (ind', par') p' c' brs') π' h')
    : ConversionResult (∥ All2 (fun u v => u.1 = v.1 ×  Σ ;;; Γ ,,, stack_context π |- u.2 = v.2) brs brs' ∥) :=

    isconv_branches' Γ ind par p c brs π h ind' par' p' c' brs' π' h' hx ei ep aux :=
      isconv_branches Γ ind par p c [] brs π _ p' c' [] brs' π' _ _ _ _.
  Next Obligation.
    constructor. constructor.
  Qed.
  Next Obligation.
    unshelve eapply aux. all: eassumption.
  Qed.

  Equations isconv_fix_types (Γ : context)
    (idx : nat)
    (mfix1 mfix2 : mfixpoint term) (π : stack)
    (h : wtp Γ (tFix (mfix1 ++ mfix2) idx) π)
    (mfix1' mfix2' : mfixpoint term) (π' : stack)
    (h' : wtp Γ (tFix (mfix1' ++ mfix2') idx) π')
    (hx : conv_stack_ctx Γ π π')
    (h1 : ∥ All2 (fun u v =>
                   Σ ;;; Γ ,,, stack_context π |- u.(dtype) = v.(dtype) ×
                   u.(rarg) = v.(rarg)
            ) mfix1 mfix1' ∥)
    (aux : Aux Term Γ (tFix (mfix1 ++ mfix2) idx) π (tFix (mfix1' ++ mfix2') idx) π' h')
    : ConversionResult (∥ All2 (fun u v =>
          Σ ;;; Γ ,,, stack_context π |- u.(dtype) = v.(dtype) ×
          u.(rarg) = v.(rarg)
      ) mfix2 mfix2' ∥)
    by struct mfix2 :=

    isconv_fix_types
      Γ idx mfix1 (u :: mfix2) π h mfix1' (v :: mfix2') π' h' hx h1 aux
    with inspect (eqb u.(rarg) v.(rarg)) := {
    | @exist true eq1
      with isconv_red_raw Conv
             u.(dtype)
             (Fix_mfix_ty u.(dname) u.(dbody) u.(rarg) mfix1 mfix2 idx π)
             v.(dtype)
             (Fix_mfix_ty v.(dname) v.(dbody) v.(rarg) mfix1' mfix2' idx π')
             aux
      := {
      | Success h2 with
          isconv_fix_types Γ idx
            (mfix1 ++ [u]) mfix2 π _
            (mfix1' ++ [v]) mfix2' π' _
            hx _ _
        := {
        | Success h3 := yes ;
        | Error e h := no e
        } ;
      | Error e h := no e
      } ;
    | @exist false eq1 := Error (
        FixRargMismatch idx
          (Γ ,,, stack_context π) u mfix1 mfix2
          (Γ ,,, stack_context π') v mfix1' mfix2'
      ) _
    } ;

    isconv_fix_types Γ idx mfix1 [] π h mfix1' [] π' h' hx h1 aux := yes ;

    (* TODO It might be more efficient to check the lengths first
       and then conclude this case is not possible.
    *)
    isconv_fix_types Γ idx mfix1 mfix2 π h mfix1' mfix2' π' h' hx h1 aux :=
      Error (
        FixMfixMismatch idx
          (Γ ,,, stack_context π) (mfix1 ++ mfix2)
          (Γ ,,, stack_context π') (mfix1' ++ mfix2')
      ) _.

  Next Obligation.
    constructor. constructor.
  Qed.
  Next Obligation.
    (* Left list is empty *)
    destruct H as [H]; inversion H.
  Qed.
  Next Obligation.
    (* Right list is empty *)
    destruct H as [H]; inversion H.
  Qed.  
  Next Obligation.
    destruct u. assumption.
  Qed.
  Next Obligation.
    destruct v. assumption.
  Qed.
  Next Obligation.
    eapply R_positionR. all: simpl.
    - destruct u. reflexivity.
    - rewrite <- app_nil_r. eapply positionR_poscat.
      constructor.
  Qed.
  Next Obligation.
    rewrite <- app_assoc. simpl. assumption.
  Qed.
  Next Obligation.
    rewrite <- app_assoc. simpl. assumption.
  Qed.
  Next Obligation.
    destruct hx as [hx], h1 as [h1], h2 as [h2].
    destruct hΣ as [wΣ].
    unfold zipp in h2. simpl in h2.
    constructor.
    apply All2_app. 1: assumption.
    constructor. 2: constructor.
    change (true = eqb u.(rarg) v.(rarg)) in eq1.
    destruct (eqb_spec u.(rarg) v.(rarg)). 2: discriminate.
    clear eq1.
    intuition eauto.
  Qed.
  Next Obligation.
    unshelve eapply aux. all: try eassumption.
    clear aux.
    lazymatch goal with
    | h : R _ _ ?r1 |- R _ _ ?r2 =>
      rename h into hr ;
      assert (e : r1 = r2)
    end.
    { clear hr.
      match goal with
      | |- {| wth := ?x |} = _ =>
        generalize x
      end.
      rewrite <- !app_assoc. simpl.
      intro w.
      f_equal.
      eapply proof_irrelevance.
    }
    rewrite <- e. assumption.
  Qed.
  Next Obligation.
    destruct hx as [hx], h1 as [h1], h2 as [h2], h3 as [h3].
    destruct hΣ as [wΣ].
    unfold zipp in h2. simpl in h2.
    constructor.
    constructor. 2: assumption.
    change (true = eqb u.(rarg) v.(rarg)) in eq1.
    destruct (eqb_spec u.(rarg) v.(rarg)). 2: discriminate.
    clear eq1.
    intuition eauto.
  Qed.
  Next Obligation.
    (* Contrapositive of previous obligation *)
    apply h; clear h.
    destruct H as [H]; inversion H.
    constructor; assumption.
  Qed.  
  Next Obligation.
    destruct H as [H]; inversion H; destruct X as [eq_uv _].
    apply h; clear h; constructor; apply eq_uv.
  Qed.
  Next Obligation.
    destruct H as [H]; inversion H; destruct X as [_ eq_uv].
    change (?ru =? ?rv) with (eqb ru rv) in eq1.
    destruct (eqb_spec (rarg u) (rarg v)) as [|neq_uv]; [discriminate|].
    exact (neq_uv eq_uv).
  Qed.

  (* TODO MOVE *)
  Lemma conv_context_decl :
    forall Γ Δ d d',
      conv_context Σ Γ Δ ->
      conv_decls Σ Γ Δ d d' ->
      conv_context Σ (Γ ,, d) (Δ ,, d').
  Proof.
    intros Γ Δ d d' hx h.
    destruct h.
    all: constructor. all: try assumption.
    all: constructor. all: assumption.
  Qed.

  Equations isconv_fix_bodies (Γ : context) (idx : nat)
    (mfix1 mfix2 : mfixpoint term) (π : stack)
    (h : wtp Γ (tFix (mfix1 ++ mfix2) idx) π)
    (mfix1' mfix2' : mfixpoint term) (π' : stack)
    (h' : wtp Γ (tFix (mfix1' ++ mfix2') idx) π')
    (hx : conv_stack_ctx Γ π π')
    (h1 : ∥ All2 (fun u v => Σ ;;; Γ ,,, stack_context π ,,, fix_context_alt (map def_sig mfix1 ++ map def_sig mfix2) |- u.(dbody) = v.(dbody)) mfix1 mfix1' ∥)
    (ha : ∥ All2 (fun u v =>
                    Σ ;;; Γ ,,, stack_context π |- u.(dtype) = v.(dtype) ×
                    u.(rarg) = v.(rarg)
           ) (mfix1 ++ mfix2) (mfix1' ++ mfix2') ∥)
    (aux : Aux Term Γ (tFix (mfix1 ++ mfix2) idx) π (tFix (mfix1' ++ mfix2') idx) π' h')
    : ConversionResult (∥ All2 (fun u v => Σ ;;; Γ ,,, stack_context π ,,, fix_context_alt (map def_sig mfix1 ++ map def_sig mfix2) |- u.(dbody) = v.(dbody)) mfix2 mfix2' ∥)
    by struct mfix2 :=

  isconv_fix_bodies Γ idx mfix1 (u :: mfix2) π h mfix1' (v :: mfix2') π' h' hx h1 ha aux
  with isconv_red_raw Conv
        u.(dbody)
        (Fix_mfix_bd u.(dname) u.(dtype) u.(rarg) mfix1 mfix2 idx π)
        v.(dbody)
        (Fix_mfix_bd v.(dname) v.(dtype) v.(rarg) mfix1' mfix2' idx π')
        aux
  := {
  | Success h2
    with isconv_fix_bodies Γ idx
           (mfix1 ++ [u]) mfix2 π _
           (mfix1' ++ [v]) mfix2' π' _
           hx _ _ _
    := {
    | Success h3 := yes ;
    | Error e h := no e
    } ;
  | Error e h := no e
  } ;

  isconv_fix_bodies Γ idx mfix1 [] π h mfix1' [] π' h' hx h1 ha aux := yes ;

  isconv_fix_bodies Γ idx mfix1 mfix2 π h mfix1' mfix2' π' h' hx h1 ha aux :=
    False_rect _ _.

  Next Obligation.
    constructor. constructor.
  Qed.
  Next Obligation.
    destruct h1 as [h1], ha as [ha].
    apply All2_length in h1 as e1.
    apply All2_length in ha as ea.
    rewrite !app_length in ea. simpl in ea. lia.
  Qed.
  Next Obligation.
    destruct h1 as [h1], ha as [ha].
    apply All2_length in h1 as e1.
    apply All2_length in ha as ea.
    rewrite !app_length in ea. simpl in ea. lia.
  Qed.
  Next Obligation.
    destruct u. assumption.
  Qed.
  Next Obligation.
    destruct v. assumption.
  Qed.
  Next Obligation.
    eapply R_positionR. all: simpl.
    - destruct u. reflexivity.
    - rewrite <- app_nil_r. eapply positionR_poscat.
      constructor.
  Qed.
  Next Obligation.
    destruct hΣ as [wΣ], ha as [ha], hx as [hx].
    clear - wΣ ha hx. constructor.
    change (dname u, dtype u) with (def_sig u).
    change (dname v, dtype v) with (def_sig v).
    repeat match goal with
    | |- context [ ?f ?x :: map ?f ?l ] =>
      change (f x :: map f l) with (map f (x :: l))
    end.
    rewrite <- 2!map_app.
    revert ha.
    generalize (mfix1 ++ u :: mfix2). intro Δ.
    generalize (mfix1' ++ v :: mfix2'). intro Δ'.
    intro ha.
    rewrite !app_context_assoc.
    revert hx ha.
    generalize (Γ ,,, stack_context π').
    generalize (Γ ,,, stack_context π).
    clear Γ. intros Γ Γ' hx ha.
    assert (h :
      All2
        (fun d d' => conv Σ Γ d.2 d'.2)
        (map def_sig Δ) (map def_sig Δ')
    ).
    { apply All2_map. eapply All2_impl. 1: eassumption.
      intros [na ty bo ra] [na' ty' bo' ra'] [? ?].
      simpl in *. assumption.
    }
    clear ha.
    revert h.
    generalize (map def_sig Δ). clear Δ. intro Δ.
    generalize (map def_sig Δ'). clear Δ'. intro Δ'.
    intro h.
    unfold fix_context_alt.
    match goal with
    | |- conv_context _ (_ ,,, List.rev ?l) (_ ,,, List.rev ?l') =>
      assert (hi :
        All2i (fun i d d' =>
          forall Ξ Θ,
            #|Ξ| = i ->
            conv_decls Σ (Γ ,,, Ξ) Θ d d'
        ) 0 l l'
      )
    end.
    { eapply All2i_mapi.
      generalize 0 at 3. intro n.
      induction h in n |- *. 1: constructor.
      constructor. 2: eapply IHh.
      intros Ξ Θ eΞ. constructor.
      rewrite <- eΞ.
      eapply @weakening_conv with (Γ' := []). all: assumption.
    }
    clear h.
    revert hi.
    match goal with
    | |- context [ conv_context _ (_ ,,, List.rev ?l) (_ ,,, List.rev ?l') ] =>
      generalize l' ;
      generalize l
    end.
    clear Δ Δ'. intros Δ Δ' h.
    apply All2i_rev in h. simpl in h.
    revert h.
    rewrite <- (List.rev_length Δ).
    generalize (List.rev Δ). clear Δ. intro Δ.
    generalize (List.rev Δ'). clear Δ'. intro Δ'.
    intro h.
    set (ln := #|Δ|) in *.
    set (m := 0) in *.
    assert (e : ln - m = #|Δ|) by lia.
    clearbody ln m.
    induction h.
    - assumption.
    - simpl in *.
      eapply conv_context_decl.
      + eapply IHh. lia.
      + eapply r0. lia.
  Qed.
  Next Obligation.
    rewrite <- app_assoc. simpl. assumption.
  Qed.
  Next Obligation.
    rewrite <- app_assoc. simpl. assumption.
  Qed.
  Next Obligation.
    destruct hx as [hx], h1 as [h1], h2 as [h2], ha as [ha].
    destruct hΣ as [wΣ].
    unfold zipp in h2. simpl in h2.
    constructor.
    apply All2_app.
    - eapply All2_impl. 1: exact h1.
      simpl. intros [? ? ? ?] [? ? ? ?] hh.
      simpl in *.
      rewrite map_app. simpl.
      rewrite <- !app_assoc. simpl.
      assumption.
    - constructor. 2: constructor.
      rewrite map_app. simpl.
      rewrite <- !app_assoc. simpl.
      destruct u as [na ty bo ra], v as [na' ty' bo' ra']. simpl in *.
      unfold def_sig at 2. simpl.
      rewrite app_context_assoc in h2.
      assumption.
  Qed.
  Next Obligation.
    destruct ha as [ha].
    constructor.
    rewrite <- !app_assoc. simpl. assumption.
  Qed.
  Next Obligation.
    unshelve eapply aux. all: try eassumption.
    clear aux.
    lazymatch goal with
    | h : R _ _ ?r1 |- R _ _ ?r2 =>
      rename h into hr ;
      assert (e : r1 = r2)
    end.
    { clear hr.
      match goal with
      | |- {| wth := ?x |} = _ =>
        generalize x
      end.
      rewrite <- !app_assoc. simpl.
      intro w.
      f_equal.
      eapply proof_irrelevance.
    }
    rewrite <- e. assumption.
  Qed.
  Next Obligation.
    destruct hx as [hx], h1 as [h1], h2 as [h2], h3 as [h3].
    destruct hΣ as [wΣ].
    unfold zipp in h2. simpl in h2.
    constructor.
    constructor.
    - destruct u as [na ty bo ra], v as [na' ty' bo' ra']. simpl in *.
      unfold def_sig at 2. simpl.
      rewrite app_context_assoc in h2.
      assumption.
    - eapply All2_impl. 1: exact h3.
      simpl. intros [? ? ? ?] [? ? ? ?] hh.
      simpl in *.
      rewrite map_app in hh. simpl in hh.
      rewrite <- !app_assoc in hh. simpl in hh.
      assumption.
  Qed.
  Next Obligation.
    apply h; clear h.
    destruct H as [H]; inversion H; constructor.
    rewrite map_app, <- app_assoc; simpl; assumption.
  Qed.  
  Next Obligation.
    apply h; clear h.
    destruct H as [H]; inversion H; constructor.
    rewrite app_context_assoc; apply X.
  Qed.  

  Equations isconv_fix (Γ : context)
    (mfix : mfixpoint term) (idx : nat) (π : stack)
    (h : wtp Γ (tFix mfix idx) π)
    (mfix' : mfixpoint term) (idx' : nat) (π' : stack)
    (h' : wtp Γ (tFix mfix' idx') π')
    (hx : conv_stack_ctx Γ π π')
    (ei : idx = idx')
    (aux : Aux Term Γ (tFix mfix idx) π (tFix mfix' idx') π' h')
    : ConversionResult (∥ All2 (fun u v =>
          Σ ;;; Γ ,,, stack_context π |- u.(dtype) = v.(dtype) ×
          Σ ;;; Γ ,,, stack_context π ,,, fix_context mfix |- u.(dbody) = v.(dbody) ×
          u.(rarg) = v.(rarg)
      ) mfix mfix' ∥) :=

    isconv_fix Γ mfix idx π h mfix' idx' π' h' hx ei aux
    with
      isconv_fix_types Γ idx
        [] mfix π _
        [] mfix' π' _
        hx _ _
    := {
    | Success h1
      with
        isconv_fix_bodies Γ idx
          [] mfix π _
          [] mfix' π' _
          hx _ _ _
      := {
      | Success h2 := yes ;
      | Error e h := no e
      } ;
    | Error e h := no e
    }.

  Next Obligation.
    constructor. constructor.
  Qed.
  Next Obligation.
    unshelve eapply aux. all: eassumption.
  Qed.
  Next Obligation.
    constructor. constructor.
  Qed.
  Next Obligation.
    unshelve eapply aux. all: eassumption.
  Qed.
  Next Obligation.
    destruct h1 as [h1], h2 as [h2].
    constructor.
    rewrite fix_context_fix_context_alt.
    pose proof (All2_mix h1 h2) as h3.
    eapply All2_impl. 1: exact h3.
    intros [? ? ? ?] [? ? ? ?] ?. simpl in *.
    intuition eauto.
  Qed.
  Next Obligation.
    (* Contrapositive of previous obligation *)
    apply h; clear h.
    destruct H as [H]; constructor.
    apply (All2_impl H).
    rewrite <- fix_context_fix_context_alt. intuition.
  Qed.  
  Next Obligation.
    (* Contrapositive of pre-previous obligation *)
    apply h; clear h.
    destruct H as [H]; constructor; apply (All2_impl H).
    intuition.
  Qed.
  
  Lemma invert_type_mkApps_tProd Γ na A b args T :
    Σ;;; Γ |- mkApps (tProd na A b) args : T -> args = [].
  Proof.
    intros typ.
    destruct hΣ.
    apply PCUICValidity.inversion_mkApps in typ as (?&typ_prod&typ_args); [|easy].
    apply inversion_Prod in typ_prod as (?&?&?&?&?); [|easy].
    eapply PCUICSpine.typing_spine_strengthen in typ_args; eauto.
    clear -typ_args.
    depelim typ_args.
    - easy.
    - now apply cumul_Sort_Prod_inv in c.
  Qed.

  Lemma wellformed_zipc_tProd_appstack_nil {Γ na A B l ρ} :
    wellformed Σ Γ (zipc (tProd na A B) (appstack l ρ)) -> l = [].
  Proof. 
    intros wh.
    rewrite zipc_appstack in wh.
    zip fold in wh.
    apply wellformed_context in wh; [|easy].
    cbn in wh.
    destruct l as [|? ? _] using List.rev_ind; [easy|].
    rewrite <- mkApps_nested in wh.
    cbn in wh.
    apply wellformed_nonarity in wh as (?&typ); auto.
    change (tApp ?h ?a) with (mkApps h [a]) in typ.
    rewrite mkApps_nested in typ.
    now apply invert_type_mkApps_tProd in typ.
  Qed.

  Lemma whnf_whne_upgrade Γ t :
    whnf RedFlags.default Σ Γ t ->
    whne RedFlags.nodelta Σ Γ t ->
    whne RedFlags.default Σ Γ t.
  Proof.
    intros whn whe.
    induction whe; cbn in *; try easy.
    - now depelim whn; solve_discr.
    - depelim whn.
      + easy.
      + destruct v0 as [|? ? _] using List.rev_ind; [discriminate H|].
        rewrite <- mkApps_nested in H.
        cbn in H; noconf H.
        constructor.
        eapply IHwhe.
        apply whnf_cstrapp.
      + destruct v0 as [|? ? _] using List.rev_ind; [discriminate H|].
        rewrite <- mkApps_nested in H.
        cbn in H; noconf H.
        constructor.
        eapply IHwhe.
        apply whnf_indapp.
      + destruct v0 as [|? ? _] using List.rev_ind; [discriminate H0|].
        rewrite <- mkApps_nested in H0.
        cbn in H0; noconf H0.
        constructor.
        eapply IHwhe.
        apply whnf_fixapp.
        destruct unfold_fix; [|easy].
        destruct p.
        apply nth_error_None.
        apply nth_error_None in H.
        rewrite app_length in H; cbn in H.
        lia.
      + destruct v0 as [|? ? _] using List.rev_ind; [discriminate H|].
        rewrite <- mkApps_nested in H.
        cbn in H; noconf H.
        constructor.
        eapply IHwhe.
        apply whnf_cofixapp.
    - depelim whn; solve_discr; try easy.
      rewrite H1 in H.
      congruence.
    - depelim whn; solve_discr; easy.
    - depelim whn; solve_discr; easy.
  Qed.
  
(* TODO: move to safe emmata *)
  Lemma whne_context_relation f rel Γ Γ' t :
    (forall Γ Γ' c c', rel Γ Γ' c c' -> (decl_body c = None <-> decl_body c' = None)) ->
    whne f Σ Γ t ->
    context_relation rel Γ Γ' ->
    whne f Σ Γ' t.
  Proof.
    intros behaves wh conv.
    induction wh; eauto using whne.
    destruct nth_error eqn:nth; [|easy].
    cbn in H.
    eapply context_relation_nth in nth; eauto.
    destruct nth as (?&?&?&?).
    constructor.
    rewrite e.
    cbn.
    specialize (behaves _ _ _ _ r).
    f_equal.
    apply behaves.
    congruence.
  Qed.
  
  Lemma whnf_context_relation f rel Γ Γ' t :
    (forall Γ Γ' c c', rel Γ Γ' c c' -> (decl_body c = None <-> decl_body c' = None)) ->
    whnf f Σ Γ t ->
    context_relation rel Γ Γ' ->
    whnf f Σ Γ' t.
  Proof.
    intros behaves wh conv.
    destruct wh; eauto using whnf.
    apply whnf_ne.
    eapply whne_context_relation; eauto.
  Qed.
  
  Lemma whne_conv_context f Γ Γ' t :
    whne f Σ Γ t ->
    conv_context Σ Γ Γ' ->
    whne f Σ Γ' t.
  Proof.
    apply whne_context_relation.
    intros ? ? ? ? r.
    now depelim r.
  Qed.
  
  Lemma whnf_conv_context f Γ Γ' t :
    whnf f Σ Γ t ->
    conv_context Σ Γ Γ' ->
    whnf f Σ Γ' t.
  Proof.
    apply whnf_context_relation.
    intros ? ? ? ? r.
    now depelim r.
  Qed.
    
  Lemma cumul_mkApps Γ hd args hd' args' :
    wf Σ ->
    Σ;;; Γ |- hd <= hd' ->
    conv_terms Σ Γ args args' ->
    Σ;;; Γ |- mkApps hd args <= mkApps hd' args'.
  Proof.
    intros wf cum cum_args.
    revert hd hd' cum.
    induction cum_args; intros hd hd' cum; auto.
    cbn.
    apply IHcum_args.
    eapply cumul_trans; auto.
    - eapply cumul_App_l; eauto.
    - eapply cumul_App_r; eauto.
  Qed.

  Lemma conv_cum_zipp leq Γ t t' π π' :
    conv_cum leq Σ Γ t t' ->
    ∥conv_terms Σ Γ (decompose_stack π).1 (decompose_stack π').1∥ ->
    conv_cum leq Σ Γ (zipp t π) (zipp t' π').
  Proof.
    intros conv conv_args.
    rewrite !zipp_as_mkApps.
    destruct leq; cbn in *.
    - sq.
      apply mkApps_conv_args; auto.
    - sq.
      apply cumul_mkApps; auto.
  Qed.

  Lemma conv_terms_conv_ctx Γ Γ' ts ts' :
    wf Σ ->
    conv_terms Σ Γ ts ts' ->
    conv_context Σ Γ Γ' ->
    conv_terms Σ Γ' ts ts'.
  Proof.
    intros wf conv ctx.
    induction conv; [constructor|].
    constructor; auto.
    eapply conv_conv_ctx; eauto.
  Qed.

  Lemma conv_terms_red Γ ts ts' tsr tsr' :
    wf Σ ->
    conv_terms Σ Γ tsr tsr' ->
    All2 (red Σ Γ) ts tsr ->
    All2 (red Σ Γ) ts' tsr' ->
    conv_terms Σ Γ ts ts'.
  Proof.
    intros wf conv all all'.
    induction conv in ts, ts', all, all' |- *; depelim all; depelim all'; [constructor|].
    constructor; [|auto].
    eapply red_conv_conv; eauto.
    symmetry.
    eapply red_conv_conv; eauto.
    symmetry.
    eauto.
  Qed.
  
  Lemma conv_terms_red' Γ Γ' ts ts' tsr tsr' :
    wf Σ ->
    conv_context Σ Γ Γ' ->
    conv_terms Σ Γ tsr tsr' ->
    All2 (red Σ Γ) ts tsr ->
    All2 (red Σ Γ') ts' tsr' ->
    conv_terms Σ Γ ts ts'.
  Proof.
    intros wf convctx conv all all2.
    eapply conv_terms_red.
    1: eauto.
    2: eauto.
    2: apply All2_same; reflexivity.
    eapply conv_terms_conv_ctx; eauto.
    2: eapply conv_context_sym; eauto.
    eapply conv_terms_red.
    1: eauto.
    3: eauto.
    2: apply All2_same; reflexivity.
    eapply conv_terms_conv_ctx; eauto.
  Qed.
  
  (* Check if the heads of an application are equal, and if so,
     if all args are convertible *)
  Notation eqb_heads_and_convertible_args leq hd hd' π π' aux :=
    (if eqb_term hd hd' then
      if isconv_args_raw leq hd π hd' π' aux then
        true
      else
        false
    else
      false).

  (* See https://github.com/coq/coq/blob/master/kernel/reduction.ml#L367 *)
  Opaque reduce_stack.
  Equations(noeqns) _isconv_prog (Γ : context) (leq : conv_pb)
            (t1 : term) (π1 : stack) (h1 : wtp Γ t1 π1)
            (t2 : term) (π2 : stack) (h2 : wtp Γ t2 π2)
            (hx : conv_stack_ctx Γ π1 π2)
            (ir1 : isred_full Γ t1 π1) (ir2 : isred_full Γ t2 π2)
            (aux : Aux Term Γ t1 π1 t2 π2 h2)
    : ConversionResult (conv_term leq Γ t1 π1 t2 π2) :=

    _isconv_prog Γ leq t1 π1 h1 t2 π2 h2 hx ir1 ir2 aux with prog_viewc t1 t2 := {
    | prog_view_App _ _ _ _ := False_rect _ _;

    | prog_view_Const c u c' u' with eq_dec c c' := {
      | left eq1 with inspect (eqb_universe_instance u u') := {
        | @exist true eq2 with isconv_args_raw leq (tConst c u) π1 (tConst c' u') π2 aux := {
          | Success h := yes ;
          (* Unfold both constants at once *)
          | Error e h with inspect (lookup_env Σ c) := {
            | @exist (Some (ConstantDecl {| cst_body := Some body |})) eq3 :=
              isconv_red leq (subst_instance_constr u body) π1
                             (subst_instance_constr u' body) π2 aux ;
            (* Inductive or not found *)
            | @exist _ _ := Error (NotFoundConstant c) _
            }
          } ;
        (* If universes are different, we unfold one of the constants *)
        | @exist false uneq_u := unfold_constants Γ leq c u π1 h1 c' u' π2 h2 _ hx aux
        } ;
      (* If the two constants are different, we unfold one of them *)
      | right uneq_c := unfold_constants Γ leq c u π1 h1 c' u' π2 h2 _ hx aux
      } ;

    | prog_view_Lambda na A1 t1 na' A2 t2
      with isconv_red_raw Conv A1 (Lambda_ty na t1 π1)
                               A2 (Lambda_ty na' t2 π2) aux := {
      | Success h :=
        isconv_red leq
                   t1 (Lambda_tm na A1 π1)
                   t2 (Lambda_tm na' A2 π2) aux ;
      | Error e h :=
        Error (
          LambdaNotConvertibleTypes
            (Γ ,,, stack_context π1) na A1 t1
            (Γ ,,, stack_context π2) na' A2 t2 e
        ) _
      } ;

    | prog_view_Prod na A1 B1 na' A2 B2
      with isconv_red_raw Conv A1 (Prod_l na B1 π1) A2 (Prod_l na' B2 π2) aux := {
      | Success h :=
        isconv_red leq
                   B1 (Prod_r na A1 π1)
                   B2 (Prod_r na' A2 π2) aux ;
      | Error e h :=
        Error (
          ProdNotConvertibleDomains
            (Γ ,,, stack_context π1) na A1 B1
            (Γ ,,, stack_context π2) na' A2 B2 e
        ) _
      } ;

    | prog_view_Case ind par p c brs ind' par' p' c' brs'
      with inspect (eqb_heads_and_convertible_args
                      leq
                      (tCase (ind, par) p c brs)
                      (tCase (ind', par') p' c' brs')
                      π1 π2 aux) := {
      | @exist true eq1 := Success _;
      | @exist false _ with inspect (reduce_term RedFlags.default Σ hΣ (Γ ,,, stack_context π1) c _) := {
        | @exist cred eq1 with inspect (reduce_term RedFlags.default Σ hΣ (Γ ,,, stack_context π2) c' _) := {
           | @exist cred' eq2 with inspect (eqb_term cred c && eqb_term cred' c') := {
              | @exist true eq3 with inspect (eqb (ind, par) (ind', par')) := {
                | @exist true eq4
                  with isconv_red_raw Conv
                        p (Case_p (ind, par) c brs π1)
                        p' (Case_p (ind',par') c' brs' π2)
                        aux := {
                  | Success h1
                    with isconv_red_raw Conv
                          c (Case (ind, par) p brs π1)
                          c' (Case (ind', par') p' brs' π2)
                          aux := {
                    | Success h2 with isconv_branches' Γ ind par p c brs π1 _ ind' par' p' c' brs' π2 _ _ _ _ aux := {
                      | Success h3 := isconv_args leq
                                                  (tCase (ind, par) p c brs) π1
                                                  (tCase (ind', par') p' c' brs') π2 aux;
                      | Error e h := Error e _
                      } ;
                    | Error e h := Error e _
                    } ;
                  | Error e h := Error e _
                  } ;
                | @exist false eqDiff :=
                  Error (
                    CaseOnDifferentInd
                      (Γ ,,, stack_context π1) ind par p c brs
                      (Γ ,,, stack_context π2) ind' par' p' c' brs'
                  ) _
                } ;
              | @exist false eq3 :=
                isconv_red leq (tCase (ind, par) p cred brs) π1
                               (tCase (ind', par') p' cred' brs') π2 aux
              }
           }
        }
      } ;

    | prog_view_Proj p c p' c' with inspect (reduce_term RedFlags.default Σ hΣ (Γ ,,, stack_context π1) c _) := {
      | @exist cred eq1 with inspect (eqb_term cred c) := {
        | @exist true eq3 with inspect (reduce_term RedFlags.default Σ hΣ (Γ ,,, stack_context π2) c' _) := {
          | @exist cred' eq2 with inspect (eqb_term cred' c') := {
            | @exist true eq4 with inspect (eqb p p') := {
              | @exist true eq5 with isconv_red_raw Conv c (Proj p π1) c' (Proj p' π2) aux := {
                | Success h1 := isconv_args leq (tProj p c) π1 (tProj p' c') π2 aux ;
                | Error e h := Error e _
                } ;
              | @exist false eq5 :=
                Error (
                  DistinctStuckProj
                    (Γ ,,, stack_context π1) p c
                    (Γ ,,, stack_context π2) p' c'
                ) _
              } ;
            | @exist false eq4 :=
              isconv_red leq
                (tProj p c) π1
                (tProj p' cred') π2
                aux
          }
        } ;
        | @exist false eq3 :=
          isconv_red leq
            (tProj p cred) π1
            (tProj p' c') π2
            aux
      }
    } ;

    | prog_view_Fix mfix idx mfix' idx'
      with inspect (eqb_heads_and_convertible_args
                      leq
                      (tFix mfix idx) 
                      (tFix mfix' idx')
                      π1 π2 aux) := {
      | @exist true eq1 := Success _;
      | @exist false eqDiff with inspect (unfold_one_fix Γ mfix idx π1 _) := {
        | @exist (Some (fn, θ)) eq1
          with inspect (decompose_stack θ) := {
          | @exist (l', θ') eq2
            with inspect (reduce_stack RedFlags.nodelta Σ hΣ (Γ ,,, stack_context θ') fn (appstack l' ε) _) := {
            | @exist (fn', ρ) eq3 :=
              isconv_prog leq fn' (ρ +++ θ') (tFix mfix' idx') π2 aux
            }
          } ;
        | @exist None unfold_fix1 with inspect (unfold_one_fix Γ mfix' idx' π2 _) := {
          | @exist (Some (fn, θ)) eq1
            with inspect (decompose_stack θ) := {
            | @exist (l', θ') eq2
              with inspect (reduce_stack RedFlags.nodelta Σ hΣ (Γ ,,, stack_context θ') fn (appstack l' ε) _) := {
              | @exist (fn', ρ) eq3 :=
                isconv_prog leq (tFix mfix idx) π1 fn' (ρ +++ θ') aux
              }
            } ;
          | @exist None unfold_fix2 with inspect (eqb idx idx') := {
            | @exist true eq4 with isconv_fix Γ mfix idx π1 _ mfix' idx' π2 _ _ _ aux := {
              | Success h1 with isconv_args_raw leq (tFix mfix idx) π1 (tFix mfix' idx') π2 aux := {
                | Success h2 := yes ;
                | Error e h := Error e _
                } ;
              | Error e h := Error e _
              } ;
            | @exist false idx_uneq :=
              Error (
                CannotUnfoldFix
                  (Γ ,,, stack_context π1) mfix idx
                  (Γ ,,, stack_context π2) mfix' idx'
              )_
            }
          }
        }
      } ;

    | prog_view_CoFix mfix idx mfix' idx'
      with inspect (eqb_term (tCoFix mfix idx) (tCoFix mfix' idx')) := {
      | @exist true eq1 := isconv_args leq (tCoFix mfix idx) π1 (tCoFix mfix' idx') π2 aux ;
      | @exist false _ :=
        Error (
          DistinctCoFix
            (Γ ,,, stack_context π1) mfix idx
            (Γ ,,, stack_context π2) mfix' idx'
        ) _ (* TODO Incomplete *)
      } ;

    | prog_view_other t1 t2 h :=
      isconv_fallback leq t1 π1 t2 π2 aux
    }.

  (* tApp *)
  Next Obligation.
    destruct ir1 as [ha1 _]. discriminate ha1.
  Qed.

  (* tConst *)
  Next Obligation.
    eapply R_stateR. all: try reflexivity.
    simpl. constructor.
  Qed.
  Next Obligation.
    apply conv_cum_zipp; auto.
    destruct hΣ.
    eapply conv_conv_cum.
    constructor. constructor.
    constructor. eapply eqb_universe_instance_spec. auto.
  Qed.
  Next Obligation.
    eapply red_wellformed ; auto.
    - exact h1.
    - constructor. eapply red_zipc.
      eapply red_const. eassumption.
  Qed.
  Next Obligation.
    eapply red_wellformed ; auto.
    - exact h2.
    - constructor. eapply red_zipc.
      eapply red_const. eassumption.
  Qed.
  Next Obligation.
    eapply R_cored. simpl.
    eapply cored_zipc.
    eapply cored_const.
    eassumption.
  Qed.
  Next Obligation.
    destruct hΣ.
    etransitivity.
    - eapply red_conv_cum_l ; try assumption.
      eapply red_zipp.
      eapply red_const. eassumption.
    - etransitivity ; try eassumption.
      eapply red_conv_cum_r ; try assumption.
      eapply red_zipp.
      eapply red_const. eassumption.
  Qed.
  Next Obligation.
    apply h; cbn; clear h.
    eapply conv_cum_red_inv.
    - exact hΣ'.
    - exact H.
    - apply red_zipp.
      eapply red_const; eauto.
    - apply red_zipp.
      eapply red_const; eauto.
  Qed.
  Next Obligation.
    apply h; clear h.
    rewrite !zipp_as_mkApps in H.
    apply conv_cum_mkApps_inv in H as [(?&?)]; eauto.
    - now constructor.
    - apply whnf_mkApps.
      eapply whne_const; eauto.
    - apply whnf_mkApps.
      eapply whne_const; eauto.
  Qed.
  Next Obligation.
    apply wellformed_zipc_tConst_inv in h1 as (?&?&?).
    unfold declared_constant in *.
    congruence.
  Qed.
  Next Obligation.
    apply wellformed_zipc_tConst_inv in h1 as (?&?&?).
    unfold declared_constant in *.
    congruence.
  Qed.
  Next Obligation.
    right; split; [easy|].
    now rewrite <- uneq_u.
  Qed.

  (* tLambda *)
  Next Obligation.
    unshelve eapply R_positionR.
    - reflexivity.
    - simpl. rewrite <- app_nil_r. eapply positionR_poscat. constructor.
  Qed.
  Next Obligation.
    unshelve eapply R_positionR.
    - reflexivity.
    - simpl. rewrite <- app_nil_r. eapply positionR_poscat. constructor.
  Qed.
  Next Obligation.
    destruct hx as [hx].
    destruct h as [h].
    constructor. constructor. 1: assumption.
    constructor.
    assumption.
  Qed.
  Next Obligation.
    destruct h0 as [h0].
    destruct hx as [hx].

    unfold zipp in h0. simpl in h0.
    unfold zipp in h. simpl in h.
    unfold zipp.
    case_eq (decompose_stack π1). intros l1 ρ1 e1.
    case_eq (decompose_stack π2). intros l2 ρ2 e2.
    pose proof (decompose_stack_eq _ _ _ e1). subst.
    pose proof (decompose_stack_eq _ _ _ e2). subst.
    rewrite stack_context_appstack in h0.
    rewrite stack_context_appstack in h.

    apply isred_full_nobeta in ir1; [|easy].
    destruct l1 ; try discriminate ir1. clear ir1.

    apply isred_full_nobeta in ir2; [|easy].
    destruct l2 ; try discriminate ir2. clear ir2.
    simpl in *.
    destruct hΣ.
    now eapply conv_cum_Lambda.
  Qed.
  Next Obligation.
    (* Contrapositive of previous obligation *)
    apply h; clear h.
    destruct h0 as [h0].
    destruct hx as [hx].

    unfold zipp in h0. simpl in h0.
    unfold zipp in H. simpl in H.
    unfold zipp.
    case_eq (decompose_stack π1). intros l1 ρ1 e1.
    case_eq (decompose_stack π2). intros l2 ρ2 e2.
    pose proof (decompose_stack_eq _ _ _ e1). subst.
    pose proof (decompose_stack_eq _ _ _ e2). subst.
    rewrite stack_context_appstack in h0.
    rewrite stack_context_appstack in H.

    apply isred_full_nobeta in ir1; [|easy].
    destruct l1 ; try discriminate ir1. clear ir1.

    apply isred_full_nobeta in ir2; [|easy].
    destruct l2 ; try discriminate ir2. clear ir2.
    rewrite e1, e2 in H.
    simpl in *.

    pose proof (wellformed_zipc_stack_context _ hΣ _ _  _ _ _ e1 h1) as
    [wf]%wellformed_wf_local.
    destruct hΣ.
    
    apply Lambda_conv_cum_inv in H. 2: assumption.
    destruct H as [_ ?]; assumption.
  Qed.
  Next Obligation.
    (* Contrapositive of previous obligation *)
    apply h; clear h.
    destruct hx as [hx].

    unfold zipp in H. simpl in H.
    unfold zipp.
    case_eq (decompose_stack π1). intros l1 ρ1 e1.
    case_eq (decompose_stack π2). intros l2 ρ2 e2.
    pose proof (decompose_stack_eq _ _ _ e1). subst.
    pose proof (decompose_stack_eq _ _ _ e2). subst.
    rewrite stack_context_appstack in H.

    apply isred_full_nobeta in ir1; [|easy].
    destruct l1 ; try discriminate ir1. clear ir1.

    apply isred_full_nobeta in ir2; [|easy].
    destruct l2 ; try discriminate ir2. clear ir2.
    rewrite e1, e2 in H.
    simpl in *.

    pose proof (wellformed_zipc_stack_context _ hΣ _ _  _ _ _ e1 h1) as
    [wf]%wellformed_wf_local.
    destruct hΣ.
    
    apply Lambda_conv_cum_inv in H. 2: assumption.
    destruct H as [[?] _]; now constructor.
  Qed.

  (* tProd *)
  Next Obligation.
    unshelve eapply R_positionR.
    - reflexivity.
    - simpl. rewrite <- app_nil_r. eapply positionR_poscat. constructor.
  Qed.
  Next Obligation.
    unshelve eapply R_positionR.
    - simpl. reflexivity.
    - simpl. rewrite <- app_nil_r. eapply positionR_poscat. constructor.
  Qed.
  Next Obligation.
    destruct hx as [hx].
    destruct h as [h].
    constructor. constructor. 1: assumption.
    constructor.
    assumption.
  Qed.
  Next Obligation.
    destruct hΣ as [wΣ].
    destruct h0 as [h0].
    destruct hx as [hx].
    unfold zipp in h0. simpl in h0.
    unfold zipp in h. simpl in h.
    unfold zipp.
    case_eq (decompose_stack π1). intros l1 ρ1 e1.
    case_eq (decompose_stack π2). intros l2 ρ2 e2.
    pose proof (decompose_stack_eq _ _ _ e1). subst.
    pose proof (decompose_stack_eq _ _ _ e2). subst.
    rewrite stack_context_appstack in h0.
    rewrite stack_context_appstack in h.

    eapply wellformed_zipc_stack_context in h1 ; tea.
    rewrite stack_context_appstack in h1.
    rewrite zipc_appstack in h1. simpl in h1.
    pose proof (wellformed_wf_local _ _ h1) as hw1.
    apply mkApps_Prod_nil' in h1 ; auto. subst.
    destruct hw1 as [hw1].
    clear aux.
    eapply wellformed_zipc_stack_context in h2 ; tea.
    rewrite stack_context_appstack in h2.
    pose proof (wellformed_wf_local _ _ h2) as hw2.
    rewrite zipc_appstack in h2.
    apply mkApps_Prod_nil' in h2 ; auto. subst.

    simpl.
    eapply conv_cum_Prod. all: auto.
  Qed.
  Next Obligation.
    (* Codomains are not convertible *)
    apply h; clear h.
    destruct hΣ as [wΣ], h0 as [h0], hx as [hx].
    unfold zipp in h0, H |- *. simpl in *.

    case_eq (decompose_stack π1). intros l1 ρ1 e1.
    case_eq (decompose_stack π2). intros l2 ρ2 e2.
    pose proof (decompose_stack_eq _ _ _ e1). subst.
    pose proof (decompose_stack_eq _ _ _ e2). subst.
    rewrite stack_context_appstack in h0, H |- *.
    rewrite e1, e2 in H.
    pose proof (wellformed_zipc_tProd_appstack_nil h1).
    pose proof (wellformed_zipc_tProd_appstack_nil h2).
    subst; simpl in *.
    apply Prod_conv_cum_inv in H. 2: assumption.
    now destruct H as [_ H].
   Qed.
  Next Obligation.
    (* Domains are not convertible *)
    apply h; clear h.
    
    destruct hΣ as [wΣ], hx as [hx].
    unfold zipp in H |- *. simpl in *.

    case_eq (decompose_stack π1). intros l1 ρ1 e1.
    case_eq (decompose_stack π2). intros l2 ρ2 e2.
    pose proof (decompose_stack_eq _ _ _ e1). subst.
    pose proof (decompose_stack_eq _ _ _ e2). subst.
    rewrite stack_context_appstack in H |- *.
    rewrite e1, e2 in H.
    pose proof (wellformed_zipc_tProd_appstack_nil h1).
    pose proof (wellformed_zipc_tProd_appstack_nil h2).
    subst; simpl in *.
    
    apply Prod_conv_cum_inv in H. 2: assumption.
    now destruct H.
  Qed.


  (* tCase *)
  Next Obligation.
    unshelve eapply R_stateR.
    all: try reflexivity.
    simpl. constructor.
  Qed.
  Next Obligation.
    destruct eqb_term eqn:eq_terms; [|congruence].
    destruct aux eqn:conv_args; [|congruence].
    apply conv_cum_zipp; auto.
    destruct hΣ.
    eapply conv_conv_cum.
    constructor. constructor.
    eapply eqb_term_spec. auto.
  Qed.
  Next Obligation.
    clear wildcard7.
    destruct hΣ as [wΣ].
    zip fold in h1. apply wellformed_context in h1 ; auto. simpl in h1.
    destruct h1 as [[T h1] | [[ctx [s [h1 _]]]]] ; [| discriminate ].
    apply inversion_Case in h1 as hh ; auto.
    destruct hh as [uni [args [mdecl [idecl [ps [pty [btys
                                 [? [? [? [? [? [? [ht0 [? ?]]]]]]]]]]]]]]].
    left. eexists. eassumption.
  Qed.
  Next Obligation.
    destruct hΣ as [wΣ].
    clear aux wildcard7.
    zip fold in h2. apply wellformed_context in h2 ; auto. simpl in h2.
    destruct h2 as [[T h2] | [[ctx [s [h2 _]]]]] ; [| discriminate ].
    apply inversion_Case in h2 as hh ; auto.
    destruct hh as [uni [args [mdecl [idecl [ps [pty [btys
                                 [? [? [? [? [? [? [ht0 [? ?]]]]]]]]]]]]]]].
    left. eexists. eassumption.
  Qed.
  Next Obligation.
    eapply R_positionR. all: simpl.
    1: reflexivity.
    rewrite <- app_nil_r.
    eapply positionR_poscat. constructor.
  Qed.
  Next Obligation.
    eapply R_positionR. all: simpl.
    1: reflexivity.
    rewrite <- app_nil_r.
    eapply positionR_poscat. constructor.
  Qed.
  Next Obligation.
    change (eq_inductive ind ind') with (eqb ind ind') in eq4.
    destruct (eqb_spec ind ind'). 2: discriminate.
    assumption.
  Qed.
  Next Obligation.
    change (eq_inductive ind ind') with (eqb ind ind') in eq4.
    destruct (eqb_spec ind ind'). 2: discriminate.
    change (Nat.eqb par par') with (eqb par par') in eq4.
    destruct (eqb_spec par par'). 2: discriminate.
    assumption.
  Qed.
  Next Obligation.
    eapply R_stateR. all: simpl. all: try reflexivity.
    constructor.
  Qed.
  Next Obligation.
    destruct h1 as [h1], h2 as [h2], h3 as [h3].
    unfold zipp in h1, h2. simpl in h1, h2.
    destruct hΣ as [wΣ].
    change (eq_inductive ind ind') with (eqb ind ind') in eq4.
    destruct (eqb_spec ind ind'). 2: discriminate.
    change (Nat.eqb par par') with (eqb par par') in eq4.
    destruct (eqb_spec par par'). 2: discriminate.
    subst.
    eapply conv_cum_zipp; auto.
    eapply conv_conv_cum.
    constructor.
    eapply conv_Case. all: assumption.
  Qed.
  Next Obligation.
    apply h; clear h.
    (* Proof idea:
      1) prove that the 2 tCase are fully whnf because the discriminees are
         equal to their full reduction
      2) prove that the 2 tCase are in conv_cum relation because they are whnf
      3) wlog leq = Conv because there is no cumulativity between tCase
      4) invert the conv judgement using that the tCase are whne
         (so preserved by wh-reductions) 
    *)
    destruct ir1 as (_&wh1), ir2 as (_&wh2).
    cbn in *.
    symmetry in eq3; apply Bool.andb_true_iff in eq3 as (c_is_red&c'_is_red).
    apply eqb_term_spec in c_is_red.
    apply eqb_term_spec in c'_is_red.
    eapply whnf_eq_term in c_is_red; [|now apply reduce_term_complete].
    eapply whnf_eq_term in c'_is_red; [|now apply reduce_term_complete].
    rewrite !zipp_as_mkApps in H.
    rewrite zipp_as_mkApps in wh1, wh2.
    apply whnf_mkApps_inv in wh1; [|easy].
    apply whnf_mkApps_inv in wh2; [|easy].
    depelim wh1; solve_discr.
    depelim wh2; solve_discr.
    depelim H; cbn in *; try easy; solve_discr.
    depelim H0; cbn in *; try easy; solve_discr.
    apply whnf_whne_upgrade in c_is_red; auto.
    apply whnf_whne_upgrade in c'_is_red; auto.
    destruct hΣ, hx.
    assert (whne RedFlags.default Σ (Γ,,, stack_context π1) c').
    { eapply whne_conv_context; eauto.
      apply conv_context_sym; eauto. }
    apply conv_cum_mkApps_inv in H1 as [(conv_case&conv_args)]; auto.
    2-3: apply whnf_mkApps; eauto using whne.
    apply conv_cum_tCase_inv in conv_case as [([= <- <-]&conv_p&conv_c&conv_brs)]; eauto.
    now constructor.
  Qed.
  Next Obligation.
    apply h; cbn; clear h.
    destruct ir1 as (_&wh1), ir2 as (_&wh2).
    cbn in *.
    symmetry in eq3; apply Bool.andb_true_iff in eq3 as (c_is_red&c'_is_red).
    apply eqb_term_spec in c_is_red.
    apply eqb_term_spec in c'_is_red.
    eapply whnf_eq_term in c_is_red; [|now apply reduce_term_complete].
    eapply whnf_eq_term in c'_is_red; [|now apply reduce_term_complete].
    rewrite !zipp_as_mkApps in H.
    rewrite zipp_as_mkApps in wh1, wh2.
    apply whnf_mkApps_inv in wh1; [|easy].
    apply whnf_mkApps_inv in wh2; [|easy].
    depelim wh1; solve_discr.
    depelim wh2; solve_discr.
    depelim H; cbn in *; try easy; solve_discr.
    depelim H0; cbn in *; try easy; solve_discr.
    apply whnf_whne_upgrade in c_is_red; auto.
    apply whnf_whne_upgrade in c'_is_red; auto.
    destruct hΣ, hx.
    assert (whne RedFlags.default Σ (Γ,,, stack_context π1) c').
    { eapply whne_conv_context; eauto.
      apply conv_context_sym; eauto. }
    apply conv_cum_mkApps_inv in H1 as [(conv_case&conv_args)]; auto.
    2-3: apply whnf_mkApps; eauto using whne.
    apply conv_cum_tCase_inv in conv_case as [([= <- <-]&conv_p&conv_c&conv_brs)]; eauto.
    now constructor.
  Qed.
  Next Obligation.
    apply h; cbn; clear h.
    destruct ir1 as (_&wh1), ir2 as (_&wh2).
    cbn in *.
    symmetry in eq3; apply Bool.andb_true_iff in eq3 as (c_is_red&c'_is_red).
    apply eqb_term_spec in c_is_red.
    apply eqb_term_spec in c'_is_red.
    eapply whnf_eq_term in c_is_red; [|now apply reduce_term_complete].
    eapply whnf_eq_term in c'_is_red; [|now apply reduce_term_complete].
    rewrite !zipp_as_mkApps in H.
    rewrite zipp_as_mkApps in wh1, wh2.
    apply whnf_mkApps_inv in wh1; [|easy].
    apply whnf_mkApps_inv in wh2; [|easy].
    depelim wh1; solve_discr.
    depelim wh2; solve_discr.
    depelim H; cbn in *; try easy; solve_discr.
    depelim H0; cbn in *; try easy; solve_discr.
    apply whnf_whne_upgrade in c_is_red; auto.
    apply whnf_whne_upgrade in c'_is_red; auto.
    destruct hΣ, hx.
    assert (whne RedFlags.default Σ (Γ,,, stack_context π1) c').
    { eapply whne_conv_context; eauto.
      apply conv_context_sym; eauto. }
    apply conv_cum_mkApps_inv in H1 as [(conv_case&conv_args)]; auto.
    2-3: apply whnf_mkApps; eauto using whne.
    apply conv_cum_tCase_inv in conv_case as [([= <- <-]&conv_p&conv_c&conv_brs)]; eauto.
    now constructor.
  Qed.
  Next Obligation.
    apply h; cbn; clear h.
    destruct ir1 as (_&wh1), ir2 as (_&wh2).
    cbn in *.
    symmetry in eq3; apply Bool.andb_true_iff in eq3 as (c_is_red&c'_is_red).
    apply eqb_term_spec in c_is_red.
    apply eqb_term_spec in c'_is_red.
    eapply whnf_eq_term in c_is_red; [|now apply reduce_term_complete].
    eapply whnf_eq_term in c'_is_red; [|now apply reduce_term_complete].
    rewrite !zipp_as_mkApps in H.
    rewrite zipp_as_mkApps in wh1, wh2.
    apply whnf_mkApps_inv in wh1; [|easy].
    apply whnf_mkApps_inv in wh2; [|easy].
    depelim wh1; solve_discr.
    depelim wh2; solve_discr.
    depelim H; cbn in *; try easy; solve_discr.
    depelim H0; cbn in *; try easy; solve_discr.
    apply whnf_whne_upgrade in c_is_red; auto.
    apply whnf_whne_upgrade in c'_is_red; auto.
    destruct hΣ, hx.
    assert (whne RedFlags.default Σ (Γ,,, stack_context π1) c').
    { eapply whne_conv_context; eauto.
      apply conv_context_sym; eauto. }
    apply conv_cum_mkApps_inv in H1 as [(conv_case&conv_args)]; auto.
    2-3: apply whnf_mkApps; eauto using whne.
    apply conv_cum_tCase_inv in conv_case as [([= <- <-]&conv_p&conv_c&conv_brs)]; eauto.
    constructor; auto.
  Qed.
  Next Obligation.
    destruct ir1 as (_&wh1), ir2 as (_&wh2).
    cbn in *.
    symmetry in eq3; apply Bool.andb_true_iff in eq3 as (c_is_red&c'_is_red).
    apply eqb_term_spec in c_is_red.
    apply eqb_term_spec in c'_is_red.
    eapply whnf_eq_term in c_is_red; [|now apply reduce_term_complete].
    eapply whnf_eq_term in c'_is_red; [|now apply reduce_term_complete].
    rewrite !zipp_as_mkApps in H.
    rewrite zipp_as_mkApps in wh1, wh2.
    apply whnf_mkApps_inv in wh1; [|easy].
    apply whnf_mkApps_inv in wh2; [|easy].
    depelim wh1; solve_discr.
    depelim wh2; solve_discr.
    depelim H; cbn in *; try easy; solve_discr.
    depelim H0; cbn in *; try easy; solve_discr.
    apply whnf_whne_upgrade in c_is_red; auto.
    apply whnf_whne_upgrade in c'_is_red; auto.
    destruct hΣ, hx.
    assert (whne RedFlags.default Σ (Γ,,, stack_context π1) c').
    { eapply whne_conv_context; eauto.
      apply conv_context_sym; eauto. }
    apply conv_cum_mkApps_inv in H1 as [(conv_case&conv_args)]; auto.
    2-3: apply whnf_mkApps; eauto using whne.
    apply conv_cum_tCase_inv in conv_case as [([= <- <-]&conv_p&conv_c&conv_brs)]; eauto.
    rewrite eq_inductive_refl, Nat.eqb_refl in eqDiff.
    congruence.
  Qed.
  Next Obligation.
    eapply red_wellformed ; auto.
    - exact h1.
    - match goal with
      | |- context [ reduce_term ?f ?Σ ?hΣ ?Γ ?t ?h ] =>
        pose proof (reduce_term_sound f Σ hΣ Γ t h) as [hr]
      end.
      constructor.
      eapply red_zipc.
      eapply red_case.
      + reflexivity.
      + assumption.
      + clear.
        induction brs ; eauto.
  Qed.
  Next Obligation.
    eapply red_wellformed ; auto.
    - exact h2.
    - match goal with
      | |- context [ reduce_term ?f ?Σ ?hΣ ?Γ ?t ?h ] =>
        pose proof (reduce_term_sound f Σ hΣ Γ t h) as [hr]
      end.
      constructor.
      eapply red_zipc.
      eapply red_case.
      + reflexivity.
      + assumption.
      + clear.
        induction brs' ; eauto.
  Qed.
  Next Obligation.
    match goal with
    | |- context [ reduce_term ?f ?Σ ?hΣ ?Γ c ?h ] =>
      destruct (reduce_stack_Req f Σ hΣ Γ c ε h) as [e | hr]
    end.
    - match goal with
      | |- context [ reduce_term ?f ?Σ ?hΣ ?Γ c' ?h ] =>
        destruct (reduce_stack_Req f Σ hΣ Γ c' ε h) as [e' | hr]
      end.
      + exfalso.
        unfold reduce_term in eq3.
        rewrite e in eq3.
        rewrite e' in eq3.
        cbn in eq3. symmetry in eq3.
        apply andb_false_elim in eq3 as [bot | bot].
        all: rewrite eqb_term_refl in bot.
        all: discriminate.
      + dependent destruction hr.
        * unshelve eapply R_cored2.
          all: try reflexivity.
          -- simpl. unfold reduce_term. rewrite e. reflexivity.
          -- simpl. eapply cored_zipc. eapply cored_case. assumption.
        * exfalso.
          destruct y'. simpl in H0. inversion H0. subst.
          unfold reduce_term in eq3.
          rewrite e in eq3.
          rewrite <- H2 in eq3.
          cbn in eq3. symmetry in eq3.
          apply andb_false_elim in eq3 as [bot | bot].
          all: rewrite eqb_term_refl in bot.
          all: discriminate.
    - dependent destruction hr.
      + eapply R_cored. simpl.
        eapply cored_zipc. eapply cored_case. assumption.
      + match goal with
        | |- context [ reduce_term ?f ?Σ ?hΣ ?Γ c' ?h ] =>
          destruct (reduce_stack_Req f Σ hΣ Γ c' ε h) as [e' | hr]
        end.
        * exfalso.
          destruct y'. simpl in H0. inversion H0. subst.
          unfold reduce_term in eq3.
          rewrite e' in eq3.
          rewrite <- H2 in eq3.
          cbn in eq3. symmetry in eq3.
          apply andb_false_elim in eq3 as [bot | bot].
          all: rewrite eqb_term_refl in bot.
          all: discriminate.
        * dependent destruction hr.
          -- unshelve eapply R_cored2.
             all: try reflexivity.
             ++ simpl. unfold reduce_term.
                destruct y'. simpl in H0. inversion H0. subst.
                rewrite <- H3. reflexivity.
             ++ simpl. eapply cored_zipc. eapply cored_case. assumption.
          -- exfalso.
             destruct y'. simpl in H0. inversion H0. subst.
             destruct y'0. simpl in H2. inversion H2. subst.
             unfold reduce_term in eq3.
             rewrite <- H4 in eq3.
             rewrite <- H5 in eq3.
             cbn in eq3. symmetry in eq3.
             apply andb_false_elim in eq3 as [bot | bot].
             all: rewrite eqb_term_refl in bot.
             all: discriminate.
  Qed.
  Next Obligation.
    destruct hΣ as [wΣ].
    destruct hx as [hx].
    match type of h with
    | context [ reduce_term ?f ?Σ ?hΣ ?Γ c ?h ] =>
      pose proof (reduce_term_sound f Σ hΣ Γ c h) as hr
    end.
    match type of h with
    | context [ reduce_term ?f ?Σ ?hΣ ?Γ c' ?h ] =>
      pose proof (reduce_term_sound f Σ hΣ Γ c' h) as hr'
    end.
    destruct hr as [hr], hr' as [hr'].
    etransitivity.
    - eapply red_conv_cum_l ; try assumption.
      eapply red_zipp.
      eapply red_case.
      + reflexivity.
      + eassumption.
      + instantiate (1 := brs).
        clear.
        induction brs ; eauto.
    - etransitivity ; try eassumption.
      eapply conv_cum_context_convp.
      + assumption.
      + eapply red_conv_cum_r. 1: assumption.
        eapply red_zipp.
        eapply red_case. 2: eassumption.
        * reflexivity.
        * clear.
          induction brs' ; eauto.
      + eapply conv_context_sym. all: auto.
  Qed.
  Next Obligation.
    apply h; clear h.
    set (redc := reduce_term _ _ _ _ _ _);
    assert (∥ red Σ.1 (Γ ,,, stack_context π1) c redc ∥)
    as [hc]
    by apply reduce_term_sound.
    set (redc' := reduce_term _ _ _ _ _ _);
    assert (∥ red Σ.1 (Γ ,,, stack_context π2) c' redc' ∥)
    as [hc']
    by apply reduce_term_sound.
    destruct hx as [hx].
    destruct hΣ as [ wfΣ].
    destruct leq.
    - set (t0 := zipp _ _).
      destruct H as [Hconv].
      constructor.
      unfold Aux in aux.
      eapply conv_red_l_inv. 1: auto. 2: apply red_zipp, red_case_c, hc.
      symmetry.
      eapply conv_conv_ctx. 1: assumption.
      2: eapply conv_context_sym; eassumption.
      eapply conv_red_l_inv. 1: auto. 2: apply red_zipp, red_case_c, hc'. 
      eapply conv_conv_ctx; try eassumption.
      symmetry; assumption.
    - destruct H as [Hconv].
      constructor.
      eapply cumul_red_l_inv. 1: auto. 2: apply red_zipp, red_case_c, hc.
      eapply cumul_conv_ctx. 1: assumption.
      2: eapply conv_context_sym; eassumption.
      eapply cumul_red_r_inv; [auto|eauto|]. 2: apply red_zipp, red_case_c, hc'.
      eapply cumul_conv_ctx; eauto.
  Qed.

  (* tProj *)
  Next Obligation.
    destruct hΣ as [wΣ].
    zip fold in h1. apply wellformed_context in h1 ; auto. simpl in h1.
    destruct h1 as [[T h1] | [[ctx [s [h1 _]]]]] ; [| discriminate ].
    apply inversion_Proj in h1 as hh. 2: auto.
    destruct hh as [? [? [? [? [? [? [? [? ?]]]]]]]].
    left. eexists. eassumption.
  Qed.
  Next Obligation.
    destruct hΣ as [wΣ].
    zip fold in h2. apply wellformed_context in h2 as h2' ; auto. simpl in h2'.
    destruct h2' as [[T h2'] | [[ctx [s [h2' _]]]]] ; [| discriminate ].
    apply inversion_Proj in h2' as hh. 2: auto.
    destruct hh as [? [? [? [? [? [? [? [? ?]]]]]]]].
    left. eexists. eassumption.
  Qed.
  Next Obligation.
    eapply R_aux_positionR. all: simpl.
    - reflexivity.
    - rewrite <- app_nil_r. apply positionR_poscat. constructor.
  Qed.
  Next Obligation.
    unshelve eapply R_stateR.
    all: try reflexivity.
    simpl. constructor.
  Qed.
  Next Obligation.
    destruct h1 as [h1].
    change (true = eqb p p') in eq5.
    destruct (eqb_spec p p'). 2: discriminate. subst.
    apply conv_cum_zipp; auto.
    eapply conv_conv_cum.
    constructor.
    eapply conv_Proj_c. assumption.
  Qed.
  Next Obligation.
    apply h; cbn; clear h.
    destruct ir1 as (_&wh1), ir2 as (_&wh2).
    cbn in *.
    rename eq3 into c_is_red.
    rename eq4 into c'_is_red.
    symmetry in c'_is_red.
    apply eqb_term_spec in c'_is_red.
    eapply whnf_eq_term in c'_is_red; [|now apply reduce_term_complete].
    symmetry in c_is_red.
    apply eqb_term_spec in c_is_red.
    eapply whnf_eq_term in c_is_red; [|now apply reduce_term_complete].
    rewrite !zipp_as_mkApps in H.
    rewrite zipp_as_mkApps in wh1, wh2.
    apply whnf_mkApps_inv in wh1; [|easy].
    apply whnf_mkApps_inv in wh2; [|easy].
    depelim wh1; solve_discr.
    depelim wh2; solve_discr.
    depelim H; cbn in *; try easy; solve_discr.
    depelim H0; cbn in *; try easy; solve_discr.
    apply whnf_whne_upgrade in c_is_red; auto.
    apply whnf_whne_upgrade in c'_is_red; auto.
    destruct hΣ, hx.
    assert (whne RedFlags.default Σ (Γ,,, stack_context π1) c').
    { eapply whne_conv_context; eauto.
      apply conv_context_sym; eauto. }
    apply conv_cum_mkApps_inv in H1 as [(conv_proj&conv_args)]; auto.
    2-3: apply whnf_mkApps; eauto using whne.
    apply conv_cum_tProj_inv in conv_proj as [(->&?)]; auto.
    constructor; auto.
  Qed.
  Next Obligation.
    apply h; cbn; clear h.
    destruct ir1 as (_&wh1), ir2 as (_&wh2).
    cbn in *.
    rename eq3 into c_is_red.
    rename eq4 into c'_is_red.
    symmetry in c'_is_red.
    apply eqb_term_spec in c'_is_red.
    eapply whnf_eq_term in c'_is_red; [|now apply reduce_term_complete].
    symmetry in c_is_red.
    apply eqb_term_spec in c_is_red.
    eapply whnf_eq_term in c_is_red; [|now apply reduce_term_complete].
    rewrite !zipp_as_mkApps in H.
    rewrite zipp_as_mkApps in wh1, wh2.
    apply whnf_mkApps_inv in wh1; [|easy].
    apply whnf_mkApps_inv in wh2; [|easy].
    depelim wh1; solve_discr.
    depelim wh2; solve_discr.
    depelim H; cbn in *; try easy; solve_discr.
    depelim H0; cbn in *; try easy; solve_discr.
    apply whnf_whne_upgrade in c_is_red; auto.
    apply whnf_whne_upgrade in c'_is_red; auto.
    destruct hΣ, hx.
    assert (whne RedFlags.default Σ (Γ,,, stack_context π1) c').
    { eapply whne_conv_context; eauto.
      apply conv_context_sym; eauto. }
    apply conv_cum_mkApps_inv in H1 as [(conv_proj&conv_args)]; auto.
    2-3: apply whnf_mkApps; eauto using whne.
    apply conv_cum_tProj_inv in conv_proj as [(->&?)]; auto.
    constructor; auto.
  Qed.
  Next Obligation.
    (* Proof idea: c and c' are whne so from H, p = p' contradicting eqDiff *)
    destruct ir1 as (_&wh1), ir2 as (_&wh2).
    cbn in *.
    rename eq3 into c_is_red.
    rename eq4 into c'_is_red.
    symmetry in c'_is_red.
    apply eqb_term_spec in c'_is_red.
    eapply whnf_eq_term in c'_is_red; [|now apply reduce_term_complete].
    symmetry in c_is_red.
    apply eqb_term_spec in c_is_red.
    eapply whnf_eq_term in c_is_red; [|now apply reduce_term_complete].
    rewrite !zipp_as_mkApps in H.
    rewrite zipp_as_mkApps in wh1, wh2.
    apply whnf_mkApps_inv in wh1; [|easy].
    apply whnf_mkApps_inv in wh2; [|easy].
    depelim wh1; solve_discr.
    depelim wh2; solve_discr.
    depelim H; cbn in *; try easy; solve_discr.
    depelim H0; cbn in *; try easy; solve_discr.
    apply whnf_whne_upgrade in c_is_red; auto.
    apply whnf_whne_upgrade in c'_is_red; auto.
    destruct hΣ, hx.
    assert (whne RedFlags.default Σ (Γ,,, stack_context π1) c').
    { eapply whne_conv_context; eauto.
      apply conv_context_sym; eauto. }
    apply conv_cum_mkApps_inv in H1 as [(conv_proj&conv_args)]; auto.
    2-3: apply whnf_mkApps; eauto using whne.
    apply conv_cum_tProj_inv in conv_proj as [(->&?)]; auto.
    rewrite eq_prod_refl in eq5;
      eauto using eq_prod_refl, Nat.eqb_refl, eq_string_refl, eq_inductive_refl.
  Qed.
  Next Obligation.
    eapply red_wellformed ; auto.
    - exact h2.
    - match goal with
      | |- context [ reduce_term ?f ?Σ ?hΣ ?Γ ?t ?h ] =>
        pose proof (reduce_term_sound f Σ hΣ Γ t h) as [hr]
      end.
      constructor.
      eapply red_zipc.
      eapply red_proj_c.
      assumption.
  Qed.
  Next Obligation.
    match goal with
    | |- context [ reduce_term ?f ?Σ ?hΣ ?Γ c' ?h ] =>
      destruct (reduce_stack_Req f Σ hΣ Γ c' ε h) as [e' | hr]
    end.
    1:{
      exfalso.
      unfold reduce_term in eq4.
      rewrite e' in eq4. cbn in eq4.
      rewrite eqb_term_refl in eq4.
      discriminate.
    }
    dependent destruction hr.
    2:{
      exfalso.
      destruct y'. simpl in H0. inversion H0. subst.
      unfold reduce_term in eq4.
      rewrite <- H2 in eq4.
      cbn in eq4.
      rewrite eqb_term_refl in eq4.
      discriminate.
    }
    unshelve eapply R_cored2.
    all: try reflexivity.
    simpl. eapply cored_zipc. eapply cored_proj. assumption.
  Qed.
  Next Obligation.
    (* destruct hΣ as [wΣ]. *)
    (* Why doesn't the above work anymore? *)
    pose proof hΣ as w. destruct w.
    destruct hx as [hx].
    match type of h with
    | context [ reduce_term ?f ?Σ ?hΣ ?Γ c' ?h ] =>
      pose proof (reduce_term_sound f Σ hΣ Γ c' h) as hr
    end.
    destruct hr as [hr].
    etransitivity.
    - eassumption.
    - eapply conv_cum_context_convp.
      + assumption.
      + eapply red_conv_cum_r ; try assumption.
        eapply red_zipp.
        eapply red_proj_c.
        eassumption.
      + eapply conv_context_sym. all: auto.
  Qed.
  Next Obligation.
    apply h; cbn; clear h.
    pose proof hΣ as w. destruct w.
    destruct hx as [hx].
    match type of eq4 with
    | context [ reduce_term ?f ?Σ ?hΣ ?Γ c' ?h ] =>
      pose proof (reduce_term_sound f Σ hΣ Γ c' h) as hr
    end.
    destruct hr as [hr].
    etransitivity; [eassumption|].
    eapply conv_cum_context_convp; eauto.
    2: eapply conv_context_sym; eauto.
    eapply red_conv_cum_l ; try assumption.
    eapply red_zipp.
    eapply red_proj_c.
    eassumption.
  Qed.
  Next Obligation.
    eapply red_wellformed ; auto.
    - exact h1.
    - match goal with
      | |- context [ reduce_term ?f ?Σ ?hΣ ?Γ ?t ?h ] =>
        pose proof (reduce_term_sound f Σ hΣ Γ t h) as [hr]
      end.
      constructor.
      eapply red_zipc.
      eapply red_proj_c.
      assumption.
  Qed.
  Next Obligation.
    match goal with
    | |- context [ reduce_term ?f ?Σ ?hΣ ?Γ c ?h ] =>
      destruct (reduce_stack_Req f Σ hΣ Γ c ε h) as [e' | hr]
    end.
    1:{
      exfalso.
      unfold reduce_term in eq3.
      rewrite e' in eq3. cbn in eq3.
      rewrite eqb_term_refl in eq3.
      discriminate.
    }
    dependent destruction hr.
    2:{
      exfalso.
      destruct y'. simpl in H0. inversion H0. subst.
      unfold reduce_term in eq3.
      rewrite <- H2 in eq3.
      cbn in eq3.
      rewrite eqb_term_refl in eq3.
      discriminate.
    }
    unshelve eapply R_cored.
    simpl. eapply cored_zipc. eapply cored_proj. assumption.
  Qed.
  Next Obligation.
    destruct hΣ as [wΣ].
    destruct hx as [hx].
    match type of h with
    | context [ reduce_term ?f ?Σ ?hΣ ?Γ c ?h ] =>
      pose proof (reduce_term_sound f Σ hΣ Γ c h) as hr
    end.
    destruct hr as [hr].
    etransitivity.
    - eapply red_conv_cum_l ; try assumption.
      eapply red_zipp.
      eapply red_proj_c.
      eassumption.
    - assumption.
  Qed.
  Next Obligation.
    apply h; cbn; clear h.
    destruct hΣ as [wΣ].
    destruct hx as [hx].
    match type of eq3 with
    | context [ reduce_term ?f ?Σ ?hΣ ?Γ c ?h ] =>
      pose proof (reduce_term_sound f Σ hΣ Γ c h) as hr
    end.
    destruct hr as [hr].
    etransitivity.
    - eapply red_conv_cum_r ; try assumption.
      eapply red_zipp.
      eapply red_proj_c.
      eassumption.
    - assumption.
  Qed.

  (* tFix *)
  Next Obligation.
    unshelve eapply R_stateR.
    all: try reflexivity.
    simpl. constructor.
  Qed.
  Next Obligation.
    destruct hΣ.
    destruct eqb_term eqn:eq_term; [|congruence].
    destruct aux eqn:eq_args; [|congruence].
    apply conv_cum_zipp; auto.
    eapply conv_conv_cum.
    constructor. constructor.
    eapply eqb_term_spec. auto.
  Qed.
  Next Obligation.
    cbn. rewrite zipc_appstack. cbn.
    apply unfold_one_fix_red_zipp in eq1 as r.
    apply unfold_one_fix_decompose in eq1 as d.
    rewrite <- eq2 in d. simpl in d.
    unfold zipp in r.
    rewrite <- eq2 in r.
    case_eq (decompose_stack π1). intros l1 ρ1 e1.
    rewrite e1 in r.
    rewrite e1 in d. simpl in d. subst.
    apply wellformed_zipc_zipp in h1 as hh1. 2: auto.
    pose proof (decompose_stack_eq _ _ _ e1). subst.
    unfold zipp in hh1. rewrite e1 in hh1.
    pose proof (red_wellformed _ hΣ hh1 r) as hh.
    rewrite stack_context_appstack in hh.
    assumption.
  Qed.
  Next Obligation.
    apply unfold_one_fix_red in eq1 as r1.
    apply unfold_one_fix_decompose in eq1 as d1.
    match type of eq3 with
    | _ = reduce_stack ?f ?Σ ?hΣ ?Γ ?t ?π ?h =>
      destruct (reduce_stack_sound f Σ hΣ Γ t π h) as [r2] ;
      pose proof (reduce_stack_decompose RedFlags.nodelta _ hΣ _ _ _ h) as d2 ;
      pose proof (reduce_stack_context f Σ hΣ Γ t π h) as c2
    end.
    rewrite <- eq3 in r2. cbn in r2. rewrite zipc_appstack in r2. cbn in r2.
    rewrite <- eq3 in d2. cbn in d2. rewrite decompose_stack_appstack in d2.
    cbn in d2.
    rewrite <- eq3 in c2. cbn in c2. rewrite stack_context_appstack in c2.
    cbn in c2.
    case_eq (decompose_stack ρ). intros l ξ e.
    rewrite e in d2. cbn in d2. subst.
    pose proof (red_wellformed _ hΣ h1 r1) as hh.
    apply red_context in r2.
    pose proof (decompose_stack_eq _ _ _ (eq_sym eq2)). subst.
    rewrite zipc_appstack in hh. cbn in r2.
    pose proof (red_wellformed _ hΣ hh (sq r2)) as hh2.
    rewrite zipc_stack_cat.
    assumption.
  Qed.
  Next Obligation.
    apply unfold_one_fix_cored in eq1 as r1.
    apply unfold_one_fix_decompose in eq1 as d1.
    match type of eq3 with
    | _ = reduce_stack ?f ?Σ ?hΣ ?Γ ?t ?π ?h =>
      destruct (reduce_stack_sound f Σ hΣ Γ t π h) as [r2]
    end.
    rewrite <- eq3 in r2.
    eapply R_cored. simpl.
    eapply red_cored_cored ; try eassumption.
    apply red_context in r2. cbn in r2.
    rewrite zipc_stack_cat.
    pose proof (decompose_stack_eq _ _ _ (eq_sym eq2)). subst.
    rewrite zipc_appstack in r2. cbn in r2.
    rewrite zipc_appstack.
    assumption.
  Qed.
  Next Obligation.
    apply unfold_one_fix_decompose in eq1 as d1.
    rewrite <- eq2 in d1. simpl in d1.
    match type of eq3 with
    | _ = reduce_stack ?f ?Σ ?hΣ ?Γ ?t ?π ?h =>
      pose proof (reduce_stack_decompose RedFlags.nodelta _ hΣ _ _ _ h) as d2
    end.
    rewrite <- eq3 in d2. cbn in d2. rewrite decompose_stack_appstack in d2.
    cbn in d2.
    case_eq (decompose_stack ρ). intros l ξ e.
    rewrite e in d2. cbn in d2. subst.
    pose proof (decompose_stack_eq _ _ _ (eq_sym eq2)). subst.
    apply decompose_stack_eq in e as ?. subst.
    rewrite stack_cat_appstack.
    rewrite stack_context_appstack.
    case_eq (decompose_stack π1). intros args ρ e'.
    simpl.
    apply decompose_stack_eq in e'. subst.
    clear eq3 eqDiff.
    rewrite stack_context_appstack in hx.
    assumption.
  Qed.
  Next Obligation.
    match type of eq3 with
    | _ = reduce_stack ?f ?Σ ?hΣ ?Γ ?t ?π ?h =>
      pose proof (reduce_stack_decompose RedFlags.nodelta _ hΣ _ _ _ h) as d2 ;
      pose proof (reduce_stack_isred f Σ hΣ Γ t π h eq_refl) as ir;
      pose proof (reduce_stack_whnf f Σ hΣ Γ t π h) as w2
    end.
    rewrite <- eq3 in ir.
    destruct ir as (?&hl).
    split; [easy|].
    rewrite <- eq3 in w2, d2.
    rewrite decompose_stack_appstack in d2.
    cbn in *.
    rewrite zipp_stack_cat.
    2: eapply decompose_stack_noStackApp; eauto.
    rewrite stack_context_stack_cat.
    now rewrite app_context_assoc.
  Qed.
  Next Obligation.
    destruct hΣ as [wΣ].
    apply unfold_one_fix_red_zipp in eq1 as r1.
    destruct r1 as [r1].
    match type of eq3 with
    | _ = reduce_stack ?f ?Σ ?hΣ ?Γ ?t ?π ?h =>
      destruct (reduce_stack_sound f Σ hΣ Γ t π h) as [r2] ;
      pose proof (reduce_stack_decompose RedFlags.nodelta _ hΣ _ _ _ h) as d2
    end.
    rewrite <- eq3 in r2.
    rewrite <- eq3 in d2. cbn in d2. rewrite decompose_stack_appstack in d2.
    cbn in d2.
    apply unfold_one_fix_decompose in eq1 as d1.
    assert (r2' : red (fst Σ) (Γ ,,, stack_context π1) (zipp fn θ) (zipp fn' (ρ +++ θ'))).
    { unfold zipp.
      case_eq (decompose_stack ρ). intros l ξ e.
      rewrite e in d2. cbn in d2. subst.
      pose proof (decompose_stack_eq _ _ _ e). subst.
      rewrite stack_cat_appstack. rewrite decompose_stack_appstack.
      rewrite <- eq2.
      cbn in r2. rewrite 2!zipc_appstack in r2. cbn in r2.
      rewrite <- eq2 in d1. cbn in d1. subst.
      case_eq (decompose_stack π1). intros l1 ρ1 e1.
      simpl. rewrite e1 in r2. simpl in r2.
      pose proof (decompose_stack_eq _ _ _ e1). subst.
      rewrite decompose_stack_twice with (1 := e1). cbn.
      rewrite app_nil_r.
      rewrite stack_context_appstack. assumption.
    }
    pose proof (red_trans _ _ _ _ _ r1 r2') as r.
    assert (e : stack_context π1 = stack_context (ρ +++ θ')).
    { case_eq (decompose_stack ρ). intros l ξ e.
      rewrite e in d2. cbn in d2. subst.
      pose proof (decompose_stack_eq _ _ _ e). subst.
      rewrite stack_cat_appstack.
      rewrite stack_context_appstack.
      rewrite <- eq2 in d1. cbn in d1. subst.
      case_eq (decompose_stack π1). intros l1 ρ1 e1.
      pose proof (decompose_stack_eq _ _ _ e1). subst.
      rewrite stack_context_appstack. reflexivity.
    }
    etransitivity.
    - eapply red_conv_cum_l. all: eassumption.
    - rewrite e. assumption.
  Qed.
  Next Obligation.
    destruct hΣ as [wΣ].
    apply unfold_one_fix_red_zipp in eq1 as r1.
    destruct r1 as [r1].
    match type of eq3 with
    | _ = reduce_stack ?f ?Σ ?hΣ ?Γ ?t ?π ?h =>
      destruct (reduce_stack_sound f Σ hΣ Γ t π h) as [r2] ;
      pose proof (reduce_stack_decompose RedFlags.nodelta _ hΣ _ _ _ h) as d2
    end.
    rewrite <- eq3 in r2.
    rewrite <- eq3 in d2. cbn in d2. rewrite decompose_stack_appstack in d2.
    cbn in d2.
    apply unfold_one_fix_decompose in eq1 as d1.
    assert (r2' : red (fst Σ) (Γ ,,, stack_context π1) (zipp fn θ) (zipp fn' (ρ +++ θ'))).
    { unfold zipp.
      case_eq (decompose_stack ρ). intros l ξ e.
      rewrite e in d2. cbn in d2. subst.
      pose proof (decompose_stack_eq _ _ _ e). subst.
      rewrite stack_cat_appstack. rewrite decompose_stack_appstack.
      rewrite <- eq2.
      cbn in r2. rewrite 2!zipc_appstack in r2. cbn in r2.
      rewrite <- eq2 in d1. cbn in d1. subst.
      case_eq (decompose_stack π1). intros l1 ρ1 e1.
      simpl. rewrite e1 in r2. simpl in r2.
      pose proof (decompose_stack_eq _ _ _ e1). subst.
      rewrite decompose_stack_twice with (1 := e1). cbn.
      rewrite app_nil_r.
      rewrite stack_context_appstack. assumption.
    }
    pose proof (red_trans _ _ _ _ _ r1 r2') as r.
    assert (e : stack_context π1 = stack_context (ρ +++ θ')).
    { case_eq (decompose_stack ρ). intros l ξ e.
      rewrite e in d2. cbn in d2. subst.
      pose proof (decompose_stack_eq _ _ _ e). subst.
      rewrite stack_cat_appstack.
      rewrite stack_context_appstack.
      rewrite <- eq2 in d1. cbn in d1. subst.
      case_eq (decompose_stack π1). intros l1 ρ1 e1.
      pose proof (decompose_stack_eq _ _ _ e1). subst.
      rewrite stack_context_appstack. reflexivity.
    }
    apply h; clear h.
    rewrite <- e.
    eapply conv_cum_red_inv; eauto.
    exact hΣ'.
  Qed.
  Next Obligation.
    cbn. rewrite zipc_appstack. cbn.
    apply unfold_one_fix_red_zipp in eq1 as r.
    apply unfold_one_fix_decompose in eq1 as d.
    rewrite <- eq2 in d. simpl in d.
    unfold zipp in r.
    rewrite <- eq2 in r.
    case_eq (decompose_stack π2). intros l2 ρ2 e2.
    rewrite e2 in r.
    rewrite e2 in d. simpl in d. subst.
    apply wellformed_zipc_zipp in h2 as hh2 ; auto.
    pose proof (decompose_stack_eq _ _ _ e2). subst.
    unfold zipp in hh2. rewrite e2 in hh2.
    pose proof (red_wellformed _ hΣ hh2 r) as hh.
    rewrite stack_context_appstack in hh.
    assumption.
  Qed.
  Next Obligation.
    apply unfold_one_fix_red in eq1 as r1.
    apply unfold_one_fix_decompose in eq1 as d1.
    match type of eq3 with
    | _ = reduce_stack ?f ?Σ ?hΣ ?Γ ?t ?π ?h =>
      destruct (reduce_stack_sound f Σ hΣ Γ t π h) as [r2] ;
      pose proof (reduce_stack_decompose RedFlags.nodelta _ hΣ _ _ _ h) as d2 ;
      pose proof (reduce_stack_context f Σ hΣ Γ t π h) as c2
    end.
    rewrite <- eq3 in r2. cbn in r2. rewrite zipc_appstack in r2. cbn in r2.
    rewrite <- eq3 in d2. cbn in d2. rewrite decompose_stack_appstack in d2.
    cbn in d2.
    rewrite <- eq3 in c2. cbn in c2. rewrite stack_context_appstack in c2.
    cbn in c2.
    case_eq (decompose_stack ρ). intros l ξ e.
    rewrite e in d2. cbn in d2. subst.
    pose proof (red_wellformed _ hΣ h2 r1) as hh.
    apply red_context in r2.
    pose proof (decompose_stack_eq _ _ _ (eq_sym eq2)). subst.
    rewrite zipc_appstack in hh. cbn in r2.
    pose proof (red_wellformed _ hΣ hh (sq r2)) as hh'.
    rewrite zipc_stack_cat. assumption.
  Qed.
  Next Obligation.
    apply unfold_one_fix_cored in eq1 as r1.
    apply unfold_one_fix_decompose in eq1 as d1.
    match type of eq3 with
    | _ = reduce_stack ?f ?Σ ?hΣ ?Γ ?t ?π ?h =>
      destruct (reduce_stack_sound f Σ hΣ Γ t π h) as [r2]
    end.
    rewrite <- eq3 in r2.
    eapply R_cored2. all: try reflexivity. simpl.
    eapply red_cored_cored ; try eassumption.
    cbn in r2.
    rewrite zipc_stack_cat.
    pose proof (decompose_stack_eq _ _ _ (eq_sym eq2)). subst.
    rewrite zipc_appstack in r2. cbn in r2.
    rewrite zipc_appstack.
    do 2 zip fold. eapply red_context.
    assumption.
  Qed.
  Next Obligation.
    apply unfold_one_fix_decompose in eq1 as d1.
    match type of eq3 with
    | _ = reduce_stack ?f ?Σ ?hΣ ?Γ ?t ?π ?h =>
      pose proof (reduce_stack_decompose RedFlags.nodelta _ hΣ _ _ _ h) as d2
    end.
    rewrite <- eq3 in d2. cbn in d2.
     rewrite decompose_stack_appstack in d2.
    cbn in d2.
    rewrite <- eq2 in d1. simpl in d1.
    case_eq (decompose_stack π2). intros args2 ρ2 e2.
    rewrite e2 in d1. simpl in d1. subst.
    case_eq (decompose_stack ρ). intros l ξ e'.
    rewrite e' in d2. simpl in d2. subst.
    apply decompose_stack_eq in e' as ?. subst.
    rewrite stack_cat_appstack.
    rewrite stack_context_appstack.
    apply decompose_stack_eq in e2 as ?. subst.
    clear eq3 eqDiff.
    rewrite stack_context_appstack in hx.
    assumption.
  Qed.
  Next Obligation.
    match type of eq3 with
    | _ = reduce_stack ?f ?Σ ?hΣ ?Γ ?t ?π ?h =>
      pose proof (reduce_stack_decompose RedFlags.nodelta _ hΣ _ _ _ h) as d2 ;
      pose proof (reduce_stack_isred f Σ hΣ Γ t π h eq_refl) as ir;
      pose proof (reduce_stack_whnf f Σ hΣ Γ t π h) as w2
    end.
    rewrite <- eq3 in d2, ir, w2.
    rewrite decompose_stack_appstack in d2.
    cbn in *.
    destruct ir as (?&hl).
    split; [easy|].
    rewrite stack_context_stack_cat.
    rewrite zipp_stack_cat.
    2: eapply decompose_stack_noStackApp; eauto.
    now rewrite app_context_assoc.
  Qed.
  Next Obligation.
    destruct hΣ as [wΣ].
    apply unfold_one_fix_red_zipp in eq1 as r1.
    destruct r1 as [r1].
    match type of eq3 with
    | _ = reduce_stack ?f ?Σ ?hΣ ?Γ ?t ?π ?h =>
      destruct (reduce_stack_sound f Σ hΣ Γ t π h) as [r2] ;
      pose proof (reduce_stack_decompose RedFlags.nodelta _ hΣ _ _ _ h) as d2
    end.
    rewrite <- eq3 in r2.
    rewrite <- eq3 in d2. cbn in d2. rewrite decompose_stack_appstack in d2.
    cbn in d2.
    apply unfold_one_fix_decompose in eq1 as d1.
    assert (r2' : ∥ red (fst Σ) (Γ ,,, stack_context π2) (zipp fn θ) (zipp fn' (ρ +++ θ')) ∥).
    { unfold zipp.
      destruct hx as [hx].
      constructor.
      case_eq (decompose_stack ρ). intros l ξ e.
      rewrite e in d2. cbn in d2. subst.
      pose proof (decompose_stack_eq _ _ _ e). subst.
      rewrite stack_cat_appstack. rewrite decompose_stack_appstack.
      rewrite <- eq2.
      cbn in r2. rewrite 2!zipc_appstack in r2. cbn in r2.
      rewrite <- eq2 in d1. cbn in d1. subst.
      case_eq (decompose_stack π2). intros l2 ρ2 e2.
      simpl. rewrite e2 in r2. simpl in r2.
      pose proof (decompose_stack_eq _ _ _ e2). subst.
      rewrite decompose_stack_twice with (1 := e2). cbn.
      rewrite app_nil_r.
      rewrite stack_context_appstack.
      assumption.
    }
    assert (e : stack_context π2 = stack_context (ρ +++ θ')).
    { case_eq (decompose_stack ρ). intros l ξ e.
      rewrite e in d2. cbn in d2. subst.
      pose proof (decompose_stack_eq _ _ _ e). subst.
      rewrite stack_cat_appstack.
      rewrite stack_context_appstack.
      rewrite <- eq2 in d1. cbn in d1. subst.
      case_eq (decompose_stack π2). intros l2 ρ2 e2. simpl.
      pose proof (decompose_stack_eq _ _ _ e2). subst.
      rewrite stack_context_appstack. reflexivity.
    }
    destruct r2' as [r2'].
    destruct hx as [hx].
    pose proof (red_trans _ _ _ _ _ r1 r2') as r.
    etransitivity ; revgoals.
    - eapply conv_cum_context_convp.
      + assumption.
      + eapply red_conv_cum_r. 1: assumption.
        eassumption.
      + eapply conv_context_sym. 1: auto.
        assumption.
    - assumption.
  Qed.
  Next Obligation.
    apply h; clear h.
    destruct hΣ as [wΣ].
    apply unfold_one_fix_red_zipp in eq1 as r1.
    destruct r1 as [r1].
    match type of eq3 with
    | _ = reduce_stack ?f ?Σ ?hΣ ?Γ ?t ?π ?h =>
      destruct (reduce_stack_sound f Σ hΣ Γ t π h) as [r2] ;
      pose proof (reduce_stack_decompose RedFlags.nodelta _ hΣ _ _ _ h) as d2
    end.
    rewrite <- eq3 in r2.
    rewrite <- eq3 in d2. cbn in d2. rewrite decompose_stack_appstack in d2.
    cbn in d2.
    apply unfold_one_fix_decompose in eq1 as d1.
    assert (r2' : ∥ red (fst Σ) (Γ ,,, stack_context π2) (zipp fn θ) (zipp fn' (ρ +++ θ')) ∥).
    { unfold zipp.
      destruct hx as [hx].
      constructor.
      case_eq (decompose_stack ρ). intros l ξ e.
      rewrite e in d2. cbn in d2. subst.
      pose proof (decompose_stack_eq _ _ _ e). subst.
      rewrite stack_cat_appstack. rewrite decompose_stack_appstack.
      rewrite <- eq2.
      cbn in r2. rewrite 2!zipc_appstack in r2. cbn in r2.
      rewrite <- eq2 in d1. cbn in d1. subst.
      case_eq (decompose_stack π2). intros l2 ρ2 e2.
      simpl. rewrite e2 in r2. simpl in r2.
      pose proof (decompose_stack_eq _ _ _ e2). subst.
      rewrite decompose_stack_twice with (1 := e2). cbn.
      rewrite app_nil_r.
      rewrite stack_context_appstack.
      assumption.
    }
    assert (e : stack_context π2 = stack_context (ρ +++ θ')).
    { case_eq (decompose_stack ρ). intros l ξ e.
      rewrite e in d2. cbn in d2. subst.
      pose proof (decompose_stack_eq _ _ _ e). subst.
      rewrite stack_cat_appstack.
      rewrite stack_context_appstack.
      rewrite <- eq2 in d1. cbn in d1. subst.
      case_eq (decompose_stack π2). intros l2 ρ2 e2. simpl.
      pose proof (decompose_stack_eq _ _ _ e2). subst.
      rewrite stack_context_appstack. reflexivity.
    }
    destruct r2' as [r2'].
    destruct hx as [hx].
    pose proof (red_trans _ _ _ _ _ r1 r2') as r.
    eapply conv_cum_conv_ctx; eauto.
    2: apply conv_context_sym; eauto.
    eapply conv_cum_red_inv; [exact hΣ'| |reflexivity|exact r].
    eapply conv_cum_conv_ctx; eauto.
  Qed.
  Next Obligation.
    change (true = eqb idx idx') in eq4.
    destruct (eqb_spec idx idx'). 2: discriminate.
    assumption.
  Qed.
  Next Obligation.
    eapply R_stateR.
    all: simpl.
    all: try reflexivity.
    constructor.
  Qed.
  Next Obligation.
    destruct h1 as [h1].
    destruct hΣ.
    change (true = eqb idx idx') in eq4.
    destruct (eqb_spec idx idx'). 2: discriminate.
    subst.
    apply conv_cum_zipp; auto.
    eapply conv_conv_cum_l.
    eapply conv_Fix. all: assumption.
  Qed.
  Next Obligation.
    apply h; clear h.
    (* Idea : Since the fixpoints do not unfold they are convertible to fixpoints
       in whnf implying that the args are convertible. *)
    rewrite !zipp_as_mkApps in H.
    apply unfold_one_fix_None in unfold_fix1 as [(?&?&?)].
    apply unfold_one_fix_None in unfold_fix2 as [(?&?&?)].
    destruct hΣ, hx.
    eapply conv_cum_red_inv' in H.
    2: exact hΣ'.
    2: eassumption.
    2: apply red_mkApps; [reflexivity|exact a].
    2: apply red_mkApps; [reflexivity|exact a0].
    apply conv_cum_mkApps_inv in H as [(_&conv_args)]; auto.
    2: eapply whnf_conv_context; eauto.
    2: eapply conv_context_sym; eauto.
    constructor.
    eapply conv_terms_red'; eauto.
  Qed.
  Next Obligation.
    apply h; clear h.
    (* Idea : Since the fixpoints do not unfold they are convertible to fixpoints
       in whnf implying that their definitions are convertible. *)
    rewrite !zipp_as_mkApps in H.
    apply unfold_one_fix_None in unfold_fix1 as [(?&?&?)].
    apply unfold_one_fix_None in unfold_fix2 as [(?&?&?)].
    destruct hΣ, hx.
    eapply conv_cum_red_inv' in H.
    2: exact hΣ'.
    2: eassumption.
    2: apply red_mkApps; [reflexivity|exact a].
    2: apply red_mkApps; [reflexivity|exact a0].
    apply conv_cum_mkApps_inv in H as [(?&?)]; auto.
    2: eapply whnf_conv_context; eauto.
    2: eapply conv_context_sym; eauto.
    cbn in c0.
    apply conv_cum_tFix_inv in c0 as [(->&?)].
    constructor.
    eapply All2_impl; eauto.
    cbn; intros; easy.
  Qed.
  Next Obligation.
    (* Idea : Since the fixpoints do not unfold they are convertible to fixpoints
       in whnf implying that the indices have to be equal. *)
    rewrite !zipp_as_mkApps in H.
    apply unfold_one_fix_None in unfold_fix1 as [(?&?&?)].
    apply unfold_one_fix_None in unfold_fix2 as [(?&?&?)].
    destruct hΣ, hx.
    eapply conv_cum_red_inv' in H.
    2: exact hΣ'.
    2: eassumption.
    2: apply red_mkApps; [reflexivity|exact a].
    2: apply red_mkApps; [reflexivity|exact a0].
    apply conv_cum_mkApps_inv in H as [(?&?)]; auto.
    2: eapply whnf_conv_context; eauto.
    2: eapply conv_context_sym; eauto.
    apply conv_cum_tFix_inv in c0 as [(->&?)].
    rewrite Nat.eqb_refl in idx_uneq.
    congruence.
  Qed.

  (* tCoFix *)
  Next Obligation.
    unshelve eapply R_stateR.
    all: try reflexivity.
    simpl. constructor.
  Qed.
  Next Obligation.
    destruct hΣ.
    apply conv_cum_zipp; auto.
    eapply conv_conv_cum.
    constructor. constructor.
    eapply eqb_term_spec. auto.
  Qed.
  (* Beware !! There is a TODO in the code *)
  Next Obligation.
    apply h; clear h.
    todo "Cofix".
  Qed.
  Next Obligation.
    todo "Cofix".
  Qed.

  (* Fallback *)
  Next Obligation.
    unshelve eapply R_stateR.
    all: try reflexivity.
    simpl. constructor.
  Qed.
  
  (* TODO MOVE *)
  Lemma App_conv' :
    forall leq Γ t1 t2 u1 u2,
      conv_cum leq Σ Γ t1 t2 ->
      Σ ;;; Γ |- u1 = u2 ->
      conv_cum leq Σ Γ (tApp t1 u1) (tApp t2 u2).
  Proof.
    intros leq Γ t1 t2 u1 u2 ht hu.
    destruct hΣ.
    destruct leq.
    - destruct ht as [ht].
      constructor. apply App_conv. all: assumption.
    - destruct ht as [ht]. constructor.
      eapply cumul_trans.
      + assumption.
      + eapply cumul_App_l. eassumption.
      + eapply cumul_App_r. assumption.
  Qed.

  Definition Aux' Γ t1 args1 l1 π1 t2 π2 h2 :=
    forall u1 u2 ca1 a1 ρ2
      (h1' : wtp Γ u1 (coApp (mkApps t1 ca1) (appstack a1 π1)))
      (h2' : wtp Γ u2 ρ2),
      let x :=
        mkpack Γ Reduction u1 (coApp (mkApps t1 ca1) (appstack a1 π1)) u2 ρ2 h2'
      in
      let y := mkpack Γ Args (mkApps t1 args1) (appstack l1 π1) t2 π2 h2 in
      (S #|ca1| + #|a1| = #|args1| + #|l1|)%nat ->
      pzt x = pzt y /\
      positionR (` (pps1 x)) (` (pps1 y)) ->
      Ret Reduction Γ u1 (coApp (mkApps t1 ca1) (appstack a1 π1)) u2 ρ2.
  
  Lemma appstack_cons a args π :
    appstack (a :: args) π = App a (appstack args π).
  Proof. reflexivity. Qed.
  
  Lemma fst_decompose_stack_nil π :
    isStackApp π = false ->
    (decompose_stack π).1 = [].
  Proof. now destruct π. Qed.
  
  Equations(noeqns) _isconv_args' (leq : conv_pb) (Γ : context)
            (t1 : term) (args1 : list term)
            (l1 : list term) (π1 : stack)
            (h1 : wtp Γ (mkApps t1 args1) (appstack l1 π1))
            (hπ1 : isStackApp π1 = false)
            (t2 : term)
            (l2 : list term) (π2 : stack)
            (h2 : wtp Γ t2 (appstack l2 π2))
            (hπ2 : isStackApp π2 = false)
            (hx : conv_stack_ctx Γ π1 π2)
            (aux : Aux' Γ t1 args1 l1 π1 t2 (appstack l2 π2) h2)
    : ConversionResult (∥conv_terms Σ (Γ,,, stack_context π1) l1 l2∥) by struct l1 :=
    _isconv_args' leq Γ t1 args1 (u1 :: l1) π1 h1 hπ1 t2 (u2 :: l2) π2 h2 hπ2 hx aux
    with aux u1 u2 args1 l1 (coApp t2 (appstack l2 π2)) _ _ _ _ Conv _ I I I := {
    | Success H1 with _isconv_args' leq Γ t1 (args1 ++ [u1]) l1 π1 _ _ (tApp t2 u2) l2 π2 _ _ _ _ := {
      | Success H2 := yes ;
      | Error e herr :=
        Error (
          StackTailError
            leq
            (Γ ,,, stack_context π1) t1 args1 u1 l1
            (Γ ,,, stack_context π2) t2 u2 l2 e
        ) _
      } ;
    | Error e herr :=
      Error (
        StackHeadError
          leq
          (Γ ,,, stack_context π1) t1 args1 u1 l1
          (Γ ,,, stack_context π2) t2 u2 l2 e
      ) _
    } ;

    _isconv_args' leq Γ t1 args1 [] π1 h1 hπ1 t2 [] π2 h2 hπ2 hx aux := yes ;

    _isconv_args' leq Γ t1 args1 l1 π1 h1 hπ1 t2 l2 π2 h2 hπ2 hx aux :=
      Error (
        StackMismatch
          (Γ ,,, stack_context π1) t1 args1 l1
          (Γ ,,, stack_context π2) t2 l2
      ) _.
  Next Obligation.
    constructor; constructor.
  Defined.
  Next Obligation.
    destruct H as [H]; depelim H.
  Qed.
  Next Obligation.
    destruct H as [H]; depelim H.
  Qed.
  Next Obligation.
    split. 1: reflexivity.
    eapply positionR_poscat. constructor.
  Defined.
  Next Obligation.
    rewrite 2!stack_context_appstack.
    assumption.
  Qed.
  Next Obligation.
    rewrite <- mkApps_nested. assumption.
  Defined.
  Next Obligation.
    simpl in H0. destruct H0 as [eq hp].
    rewrite app_length in H. cbn in H.
    eapply aux. all: auto.
    - cbn. lia.
    - instantiate (1 := h2'). simpl. split.
      + rewrite <- mkApps_nested in eq. assumption.
      + subst x y.
        rewrite 2!stack_position_appstack.
        rewrite <- !app_assoc. apply positionR_poscat.
        assert (h' : forall n m, positionR (list_make n app_l ++ [app_r]) (list_make m app_l)).
        { clear. intro n. induction n ; intro m.
          - destruct m ; constructor.
          - destruct m.
            + constructor.
            + cbn. constructor. apply IHn.
        }
        rewrite <- list_make_app_r.
        apply (h' #|a1| (S #|l1|)).
  Defined.
  Next Obligation.
    destruct hΣ as [wΣ].
    destruct H1 as [H1].
    unfold zipp. simpl.
    unfold zipp in H1. simpl in H1.
    rewrite stack_context_appstack in H1.
    destruct H2 as [H2].
    constructor; constructor; auto.
  Defined.
  Next Obligation.
    apply herr; clear herr.
    destruct H as [H]; depelim H.
    constructor; auto.
  Qed.
  Next Obligation.
    apply herr; cbn; clear herr.
    destruct H as [H]; depelim H.
    rewrite stack_context_appstack.
    constructor; auto.
  Qed.

  Equations(noeqns) _isconv_args (leq : conv_pb) (Γ : context)
           (t1 : term) (π1 : stack) (h1 : wtp Γ t1 π1)
           (t2 : term) (π2 : stack) (h2 : wtp Γ t2 π2)
           (hx : conv_stack_ctx Γ π1 π2)
           (aux : Aux Args Γ t1 π1 t2 π2 h2)
    : ConversionResult (∥conv_terms Σ (Γ,,, stack_context π1)
                         (decompose_stack π1).1
                         (decompose_stack π2).1∥) :=
    _isconv_args leq Γ t1 π1 h1 t2 π2 h2 hx aux with inspect (decompose_stack π1) := {
    | @exist (l1, θ1) eq1 with inspect (decompose_stack π2) := {
      | @exist (l2, θ2) eq2 with _isconv_args' leq Γ t1 [] l1 θ1 _ _ t2 l2 θ2 _ _ _ _ := {
        | Success h := yes ;
        | Error e h := Error e _
        }
      }
    }.
  Next Obligation.
    pose proof (decompose_stack_eq _ _ _ (eq_sym eq1)). subst.
    assumption.
  Qed.
  Next Obligation.
    eapply decompose_stack_noStackApp. eauto.
  Qed.
  Next Obligation.
    pose proof (decompose_stack_eq _ _ _ (eq_sym eq2)). subst.
    assumption.
  Qed.
  Next Obligation.
    eapply decompose_stack_noStackApp. eauto.
  Qed.
  Next Obligation.
    pose proof (decompose_stack_eq _ _ _ (eq_sym eq1)). subst.
    pose proof (decompose_stack_eq _ _ _ (eq_sym eq2)). subst.
    rewrite 2!stack_context_appstack in hx.
    assumption.
  Qed.
  Next Obligation.
    specialize (aux Reduction) as h. cbn in h.
    eapply h. all: auto.
    pose proof (decompose_stack_eq _ _ _ (eq_sym eq1)). subst.
    instantiate (1 := h2').
    simpl in H0. destruct H0 as [eq hp].
    unshelve eapply R_positionR. 2: assumption.
    simpl. rewrite eq. reflexivity.
  Qed.
  (* The obligation tactic wipes out a useful hypothesis here? *)
  Obligation Tactic := idtac.
  Next Obligation.
    intros; cbn in *.
    rewrite <- (stack_context_decompose π1).
    rewrite <- eq1, <- eq2.
    auto.
  Qed.
  Next Obligation.
    intros; cbn in *.
    rewrite <- (stack_context_decompose π1).
    rewrite <- eq1, <- eq2.
    auto.
  Qed.
  Obligation Tactic :=
    Tactics.program_simplify; CoreTactics.equations_simpl; try Tactics.program_solve_wf.
  
  Equations unfold_one_case (Γ : context) (ind : inductive) (par : nat)
            (p c : term) (brs : list (nat × term))
            (h : wellformed Σ Γ (tCase (ind, par) p c brs)) : option term :=
    unfold_one_case Γ ind par p c brs h
    with inspect (reduce_stack RedFlags.default Σ hΣ Γ c ε _) := {
    | @exist (cred, ρ) eq with cc_viewc cred := {
      | ccview_construct ind' n ui with inspect (decompose_stack ρ) := {
        | @exist (args, ξ) eq' := Some (iota_red par n args brs)
        } ;
      | ccview_cofix mfix idx with inspect (unfold_cofix mfix idx) := {
        | @exist (Some (narg, fn)) eq2 with inspect (decompose_stack ρ) := {
          | @exist (args, ξ) eq' := Some (tCase (ind, par) p (mkApps fn args) brs)
          } ;
        | @exist None eq2 := False_rect _ _ (* why does ! not work in this file? *)
        } ;
      | ccview_other t _ := None
      }
    }.

  Next Obligation.
    destruct hΣ as [wΣ].
    cbn. destruct h as [[T h] | [[ctx [s [h1 _]]]]]; [| discriminate ].
    apply inversion_Case in h ; auto.
    destruct h as [uni [args [mdecl [idecl [ps [pty [btys
                                 [? [? [? [? [? [? [ht0 [? ?]]]]]]]]]]]]]]].
    left; eexists. eassumption.
  Qed.
  Next Obligation.
    exfalso.
    match type of eq with
    | _ = reduce_stack ?f ?Σ ?hΣ ?Γ ?t ?π ?h =>
      pose proof (reduce_stack_sound f Σ hΣ Γ t π h) as [r] ;
        pose proof (reduce_stack_decompose f Σ hΣ Γ t π h) as decomp
    end.
    rewrite <- eq in r, decomp.
    cbn in *.
    destruct (decompose_stack ρ) eqn:decomp'.
    apply decompose_stack_eq in decomp' as ->.
    cbn in *; subst.
    rewrite zipc_appstack in r.
    cbn in *.
    clear eq.
    apply wellformed_nonarity in h as (?&typ); auto.
    destruct hΣ.
    apply inversion_Case in typ as (?&?&?&?&?&?&?&?&?&?&?&?&?&?&?&?&?); auto.
    eapply PCUICSR.subject_reduction in t0; eauto.
    apply PCUICValidity.inversion_mkApps in t0 as (?&?&?); auto.
    apply inversion_CoFix in t0 as (?&?&?&?&?&?&?); auto.
    unfold unfold_cofix in eq2.
    rewrite e3 in eq2.
    congruence.
  Qed.

  Lemma unfold_one_case_cored :
    forall Γ ind par p c brs h t,
      Some t = unfold_one_case Γ ind par p c brs h ->
      cored Σ Γ t (tCase (ind, par) p c brs).
  Proof.
    intros Γ ind par p c brs h t e.
    revert e.
    funelim (unfold_one_case Γ ind par p c brs h).
    all: intros eq ; noconf eq.
    - match type of e with
      | _ = reduce_stack ?f ?Σ ?hΣ ?Γ ?t ?π ?h =>
        pose proof (reduce_stack_sound f Σ hΣ Γ t π h) as [r] ;
        pose proof (reduce_stack_decompose f Σ hΣ Γ t π h) as d
      end.
      rewrite <- e in r.
      rewrite <- e in d. cbn in d. rewrite <- e0 in d. cbn in d. subst.
      cbn in r.
      clear H. symmetry in e0. apply decompose_stack_eq in e0. subst.
      rewrite zipc_appstack in r. cbn in r.
      assert (r' : ∥ red Σ Γ (tCase (ind, par) p c brs) (tCase (ind, par) p (mkApps (tConstruct ind0 n ui) l) brs) ∥).
      { constructor. eapply red_case_c. eassumption. }
      pose proof (red_wellformed _ hΣ h r') as h'.
      eapply Case_Construct_ind_eq in h' ; eauto. subst.
      eapply cored_red_cored.
      + constructor. eapply red_iota.
      + eapply red_case_c. eassumption.
    - match type of eq with
      | _ = False_rect _ ?f => destruct f
      end.
    - match type of e with
      | _ = reduce_stack ?f ?Σ ?hΣ ?Γ ?t ?π ?h =>
        pose proof (reduce_stack_sound f Σ hΣ Γ t π h) as [r] ;
        pose proof (reduce_stack_decompose f Σ hΣ Γ t π h) as d
      end.
      rewrite <- e in r.
      rewrite <- e in d. cbn in d. rewrite <- e1 in d. cbn in d. subst.
      cbn in r.
      clear H. symmetry in e1. apply decompose_stack_eq in e1. subst.
      rewrite zipc_appstack in r. cbn in r.
      assert (r' : ∥ red Σ Γ (tCase (ind, par) p c brs) (tCase (ind, par) p (mkApps (tCoFix mfix idx) l) brs) ∥).
      { constructor. eapply red_case_c. eassumption. }
      pose proof (red_wellformed _ hΣ h r') as h'.
      eapply cored_red_cored.
      + constructor. eapply red_cofix_case. eauto.
      + eapply red_case_c. eassumption.
  Qed.
  
  Lemma unfold_one_case_None Γ ind par p c brs h :
    None = unfold_one_case Γ ind par p c brs h ->
    ∥∑ c', red Σ Γ c c' × whne RedFlags.default Σ Γ c'∥.
  Proof.
    funelim (unfold_one_case Γ ind par p c brs h); intros [=].
    - match type of e with
      | _ = reduce_stack ?f ?Σ ?hΣ ?Γ ?t ?π ?h =>
        pose proof (reduce_stack_sound f Σ hΣ Γ t π h) as [r] ;
          pose proof (reduce_stack_whnf f Σ hΣ Γ t π h) as wh;
          pose proof (reduce_stack_isred f Σ hΣ Γ t π h eq_refl) as isr;
          pose proof (reduce_stack_decompose f Σ hΣ Γ t π h) as decomp
      end.
      rewrite <- e in r, decomp, wh, isr.
      cbn in *.
      constructor; exists (zipc t0 s).
      split; [easy|].
      destruct (decompose_stack s) eqn:decomp'.
      apply decompose_stack_eq in decomp' as ->.
      cbn in *; subst.
      rewrite zipc_appstack in r |- *.
      rewrite zipp_appstack, stack_context_appstack in wh.
      cbn in *.
      destruct isr as (noapp&_).
      clear e H.
      apply wellformed_nonarity in h as (?&typ); auto.
      destruct hΣ.
      eapply PCUICSR.subject_reduction in typ.
      2: eauto.
      2: eapply red_case_c; eauto.
      eapply whnf_case_arg_whne; eauto.
      now destruct t0.
    - match type of H2 with
      | _ = False_rect _ ?f => destruct f
      end.
  Qed.

  Equations unfold_one_proj (Γ : context) (p : projection) (c : term)
            (h : wellformed Σ Γ (tProj p c)) : option term :=

    unfold_one_proj Γ p c h with p := {
    | (i, pars, narg) with inspect (reduce_stack RedFlags.default Σ hΣ Γ c ε _) := {
      | @exist (cred, ρ) eq with cc0_viewc cred := {
        | cc0view_construct ind' ui with inspect (decompose_stack ρ) := {
          | @exist (args, ξ) eq' with inspect (nth_error args (pars + narg)) := {
            | @exist (Some arg) eq2 := Some arg ;
            | @exist None _ := False_rect _ _
            }
          } ;
        | cc0view_cofix mfix idx with inspect (decompose_stack ρ) := {
          | @exist (args, ξ) eq' with inspect (unfold_cofix mfix idx) := {
            | @exist (Some (narg, fn)) eq2 :=
              Some (tProj (i, pars, narg) (mkApps fn args)) ;
            | @exist None eq2 := False_rect _ _
            }
          } ;
        | cc0view_other t _ := None
        }
      }
    }.
  Next Obligation.
    destruct hΣ as [wΣ].
    cbn. destruct h as [[T h] | [[ctx [s [h1 _]]]]]; [| discriminate ].
    apply inversion_Proj in h ; auto.
    destruct h as [uni [mdecl [idecl [pdecl [args' [? [? [? ?]]]]]]]].
    left. eexists. eassumption.
  Qed.
  Next Obligation.
    match type of eq with
    | _ = reduce_stack ?f ?Σ ?hΣ ?Γ ?t ?π ?h =>
      pose proof (reduce_stack_sound f Σ hΣ Γ t π h) as [r] ;
        pose proof (reduce_stack_decompose f Σ hΣ Γ t π h) as decomp
    end.
    rewrite <- eq in r, decomp.
    cbn in *.
    destruct (decompose_stack ρ) eqn:decomp'.
    apply decompose_stack_eq in decomp' as ->.
    noconf eq'.
    cbn in *; subst.
    rewrite zipc_appstack in r.
    cbn in *.
    clear eq.
    apply wellformed_nonarity in h as (?&typ); auto.
    destruct hΣ.
    apply inversion_Proj in typ as (?&?&?&?&?&decl&?&?&?); auto.
    assert (d := decl).
    eapply PCUICSR.subject_reduction in t; eauto.
    apply PCUICValidity.inversion_mkApps in t as spine; auto.
    destruct spine as (?&typ_ctor&_).
    apply inversion_Construct in typ_ctor as (?&?&?&?&decl_ctor&?&?); auto.
    destruct hΣ as [wfΣ].
    eapply PCUICInductiveInversion.Construct_Ind_ind_eq with (wfΣ0 := wfΣ) (Hdecl := decl_ctor) in t.
    cbn in t.
    destruct decl_ctor as (?&?); cbn in *.
    destruct All2_nth_error_Some; cbn in t.
    destruct p0; cbn in t.
    destruct t as ((((<-&?)&?)&?)&?).
    clear s.
    destruct decl as (?&?&?).
    pose proof (PCUICInductiveInversion.declared_inductive_unique_sig d0 H) as H''; noconf H''.
    cbn in *.
    pose proof (PCUICWeakeningEnv.on_declared_projection wfΣ d) as (_&proj').
    destruct d.
    pose proof (PCUICInductiveInversion.declared_inductive_unique_sig H d) as H''; noconf H''.
    cbn in *.
    destruct ind_cshapes; [easy|].
    destruct l; [|easy].
    noconf e1.
    destruct proj' as ((_&?)&_).
    symmetry in wildcard.
    apply nth_error_None in wildcard.
    lia.
  Qed.
  Next Obligation.
    match type of eq with
    | _ = reduce_stack ?f ?Σ ?hΣ ?Γ ?t ?π ?h =>
      pose proof (reduce_stack_sound f Σ hΣ Γ t π h) as [r] ;
        pose proof (reduce_stack_decompose f Σ hΣ Γ t π h) as decomp
    end.
    rewrite <- eq in r, decomp.
    cbn in *.
    destruct (decompose_stack ρ) eqn:decomp'.
    apply decompose_stack_eq in decomp' as ->.
    cbn in *; subst.
    rewrite zipc_appstack in r.
    cbn in *.
    clear eq.
    apply wellformed_nonarity in h as (?&typ); auto.
    destruct hΣ.
    apply inversion_Proj in typ as (?&?&?&?&?&?&?&?&?); auto.
    eapply PCUICSR.subject_reduction in t; eauto.
    apply PCUICValidity.inversion_mkApps in t as (?&?&?); auto.
    apply inversion_CoFix in t as (?&?&?&?&?&?&?); auto.
    unfold unfold_cofix in eq2.
    rewrite e0 in eq2.
    congruence.
  Qed.

  Lemma unfold_one_proj_cored :
    forall Γ p c h t,
      Some t = unfold_one_proj Γ p c h ->
      cored Σ Γ t (tProj p c).
  Proof.
    intros Γ p c h t e.
    revert e.
    funelim (unfold_one_proj Γ p c h).
    all: intros eq ; noconf eq.
    - match type of e with
      | _ = reduce_stack ?f ?Σ ?hΣ ?Γ ?t ?π ?h =>
        pose proof (reduce_stack_sound f Σ hΣ Γ t π h) as [r] ;
        pose proof (reduce_stack_decompose f Σ hΣ Γ t π h) as d
      end.
      rewrite <- e in r.
      rewrite <- e in d. cbn in d. rewrite <- e0 in d. cbn in d. subst.
      cbn in r.
      clear H0. symmetry in e0. apply decompose_stack_eq in e0. subst.
      rewrite zipc_appstack in r. cbn in r.
      pose proof (red_proj_c (i, n0, n) _ _ r) as r'.
      pose proof (red_wellformed _ hΣ h (sq r')) as h'.
      apply Proj_Constuct_ind_eq in h' ; auto. subst.
      eapply cored_red_cored.
      + constructor. eapply red_proj. eauto.
      + eapply red_proj_c. eassumption.
    - match type of eq with
      | _ = False_rect _ ?f => destruct f
      end.
    - match type of e with
      | _ = reduce_stack ?f ?Σ ?hΣ ?Γ ?t ?π ?h =>
        pose proof (reduce_stack_sound f Σ hΣ Γ t π h) as [r] ;
        pose proof (reduce_stack_decompose f Σ hΣ Γ t π h) as d
      end.
      rewrite <- e in r.
      rewrite <- e in d. cbn in d. rewrite <- e0 in d. cbn in d. subst.
      cbn in r.
      clear H0. symmetry in e0. apply decompose_stack_eq in e0. subst.
      rewrite zipc_appstack in r. cbn in r.
      pose proof (red_proj_c (i, n0, n) _ _ r) as r'.
      pose proof (red_wellformed _ hΣ h (sq r')) as h'.
      eapply cored_red_cored.
      + constructor. eapply red_cofix_proj. eauto.
      + eapply red_proj_c. eassumption.
    - match type of eq with
      | _ = False_rect _ ?f => destruct f
      end.
  Qed.

  Lemma unfold_one_proj_None Γ p c h :
    None = unfold_one_proj Γ p c h ->
    ∥∑ c', red Σ Γ c c' × whne RedFlags.default Σ Γ c'∥.
  Proof.
    funelim (unfold_one_proj Γ p c h); intros [=].
    - match type of e with
      | _ = reduce_stack ?f ?Σ ?hΣ ?Γ ?t ?π ?h =>
        pose proof (reduce_stack_sound f Σ hΣ Γ t π h) as [r] ;
          pose proof (reduce_stack_whnf f Σ hΣ Γ t π h) as wh;
          pose proof (reduce_stack_isred f Σ hΣ Γ t π h eq_refl) as isr;
          pose proof (reduce_stack_decompose f Σ hΣ Γ t π h) as decomp
      end.
      rewrite <- e in r, decomp, wh, isr.
      cbn in *.
      constructor; exists (zipc t0 s).
      split; [easy|].
      destruct (decompose_stack s) eqn:decomp'.
      apply decompose_stack_eq in decomp' as ->.
      cbn in *; subst.
      rewrite zipc_appstack in r |- *.
      rewrite zipp_appstack, stack_context_appstack in wh.
      cbn in *.
      destruct isr as (noapp&_).
      clear e H.
      apply wellformed_nonarity in h as (?&typ); auto.
      destruct hΣ.
      eapply PCUICSR.subject_reduction in typ.
      2: eauto.
      2: eapply red_proj_c; eauto.
      eapply whnf_proj_arg_whne; eauto.
      now destruct t0.
    - match type of H3 with
      | _ = False_rect _ ?f => destruct f
      end.
    - match type of H3 with
      | _ = False_rect _ ?f => destruct f
      end.
  Qed.

  Equations reducible_head (Γ : context) (t : term) (π : stack)
            (h : wtp Γ t π)
    : option (term × stack) :=

    reducible_head Γ (tFix mfix idx) π h := unfold_one_fix Γ mfix idx π h ;

    reducible_head Γ (tCase (ind, par) p c brs) π h
    with inspect (unfold_one_case (Γ ,,, stack_context π) ind par p c brs _) := {
    | @exist (Some t) eq :=Some (t, π) ;
    | @exist None _ := None
    } ;

    reducible_head Γ (tProj p c) π h
    with inspect (unfold_one_proj (Γ ,,, stack_context π) p c _) := {
    | @exist (Some t) eq := Some (t, π) ;
    | @exist None _ := None
    } ;

    reducible_head Γ (tConst c u) π h
    with inspect (lookup_env Σ c) := {
    | @exist (Some (ConstantDecl {| cst_body := Some body |})) eq :=
      Some (subst_instance_constr u body, π) ;
    | @exist _ _ := None
    } ;

    reducible_head Γ _ π h := None.
  Next Obligation.
    zip fold in h.
    apply wellformed_context in h ; auto.
  Qed.
  Next Obligation.
    zip fold in h.
    apply wellformed_context in h ; auto.
  Qed.

  Lemma reducible_head_red_zipp :
    forall Γ t π h fn ξ,
      Some (fn, ξ) = reducible_head Γ t π h ->
      ∥ red (fst Σ) (Γ ,,, stack_context π) (zipp t π) (zipp fn ξ) ∥.
  Proof.
    intros Γ t π h fn ξ e.
    revert e.
    funelim (reducible_head Γ t π h).
    all: intro ee ; noconf ee.
    - eapply unfold_one_fix_red_zipp. eassumption.
    - constructor. unfold zipp.
      case_eq (decompose_stack π). intros l s eq.
      eapply red_mkApps_f.
      eapply trans_red.
      + reflexivity.
      + eapply red_delta.
        * unfold declared_constant. eauto.
        * reflexivity.
    - apply unfold_one_case_cored in e as r. apply cored_red in r.
      destruct r as [r].
      constructor. unfold zipp.
      case_eq (decompose_stack π). intros l s e'.
      eapply red_mkApps_f.
      apply decompose_stack_eq in e'. subst.
      assumption.
    - apply unfold_one_proj_cored in e as r. apply cored_red in r.
      destruct r as [r].
      constructor. unfold zipp.
      case_eq (decompose_stack π). intros l s e'.
      eapply red_mkApps_f.
      apply decompose_stack_eq in e'. subst.
      assumption.
  Qed.

  Lemma reducible_head_red_zippx :
    forall Γ t π h fn ξ,
      Some (fn, ξ) = reducible_head Γ t π h ->
      ∥ red (fst Σ) Γ (zippx t π) (zippx fn ξ) ∥.
  Proof.
    intros Γ t π h fn ξ e.
    revert e.
    funelim (reducible_head Γ t π h).
    all: intro ee ; noconf ee.
    - eapply unfold_one_fix_red_zippx. eassumption.
    - constructor. unfold zippx.
      case_eq (decompose_stack π). intros l s eq.
      eapply red_it_mkLambda_or_LetIn. eapply red_mkApps_f.
      eapply trans_red.
      + reflexivity.
      + eapply red_delta.
        * unfold declared_constant. eauto.
        * reflexivity.
    - apply unfold_one_case_cored in e as r. apply cored_red in r.
      destruct r as [r].
      constructor. unfold zippx.
      case_eq (decompose_stack π). intros l s e'.
      eapply red_it_mkLambda_or_LetIn. eapply red_mkApps_f.
      apply decompose_stack_eq in e'. subst.
      rewrite stack_context_appstack in r. assumption.
    - apply unfold_one_proj_cored in e as r. apply cored_red in r.
      destruct r as [r].
      constructor. unfold zippx.
      case_eq (decompose_stack π). intros l s e'.
      eapply red_it_mkLambda_or_LetIn. eapply red_mkApps_f.
      apply decompose_stack_eq in e'. subst.
      rewrite stack_context_appstack in r. assumption.
  Qed.

  Lemma reducible_head_cored :
    forall Γ t π h fn ξ,
      Some (fn, ξ) = reducible_head Γ t π h ->
      cored Σ Γ (zipc fn ξ) (zipc t π).
  Proof.
    intros Γ t π h fn ξ e.
    revert e.
    funelim (reducible_head Γ t π h).
    all: intro ee ; noconf ee.
    - eapply unfold_one_fix_cored. eassumption.
    - repeat zip fold. eapply cored_context.
      constructor. eapply red_delta.
      + unfold declared_constant. eauto.
      + reflexivity.
    - repeat zip fold. eapply cored_context.
      eapply unfold_one_case_cored. eassumption.
    - repeat zip fold. eapply cored_context.
      eapply unfold_one_proj_cored. eassumption.
  Qed.

  Lemma reducible_head_decompose :
    forall Γ t π h fn ξ,
      Some (fn, ξ) = reducible_head Γ t π h ->
      snd (decompose_stack π) = snd (decompose_stack ξ).
  Proof.
    intros Γ t π h fn ξ e.
    revert e.
    funelim (reducible_head Γ t π h).
    all: intro ee ; noconf ee.
    - eapply unfold_one_fix_decompose. eassumption.
    - reflexivity.
    - reflexivity.
    - reflexivity.
  Qed.
  
  Lemma reducible_head_None Γ t π h :
    isApp t = false ->
    whnf RedFlags.nodelta Σ (Γ,,, stack_context π) (mkApps t (decompose_stack π).1) ->
    None = reducible_head Γ t π h ->
    ∥∑ t' args',
      whnf_red Σ (Γ,,, stack_context π) t t' ×
      All2 (red Σ (Γ,,, stack_context π)) (decompose_stack π).1 args' ×
      whnf RedFlags.default Σ (Γ,,, stack_context π) (mkApps t' args')∥.
  Proof.
    funelim (reducible_head Γ t π h); intros notapp wh [=].
    - apply whnf_mkApps_inv in wh; auto.
      depelim wh; solve_discr.
      depelim H; solve_discr; try discriminate.
      constructor; eexists _, (decompose_stack π).1.
      split; [now constructor|].
      split; eauto with pcuic.
      apply whnf_mkApps.
      eauto with pcuic.
    - apply whnf_mkApps_inv in wh; auto.
      depelim wh; solve_discr.
      constructor; eexists _, (decompose_stack π).1.
      split; [constructor|].
      split; eauto with pcuic.
      apply whnf_mkApps.
      constructor.
    - apply whnf_mkApps_inv in wh; auto.
      depelim wh; solve_discr.
      constructor; eexists _, (decompose_stack π).1.
      split; [constructor; eauto with pcuic|].
      split; eauto with pcuic.
      apply whnf_mkApps.
      depelim H; solve_discr; eauto with pcuic.
    - apply whnf_mkApps_tSort_inv in wh as ->.
      constructor; eexists _, [].
      eauto using whnf_red with pcuic.
    - apply whnf_mkApps_tProd_inv in wh as ->.
      constructor; eexists _, [].
      eauto using whnf_red with pcuic.
    - depelim wh; solve_discr.
      + apply whne_mkApps_inv in H as [|(?&?&?&?&?&?&?&?&?)]; auto; try discriminate.
        depelim H; solve_discr.
        discriminate.
      + rewrite H1.
        constructor; eexists _, []; eauto using whnf_red with pcuic.
    - apply whnf_mkApps_inv in wh; auto.
      depelim wh; solve_discr.
      depelim H; solve_discr.
      discriminate.
    - discriminate.
    - constructor; eexists _, (decompose_stack π).1; eauto using whnf_red with pcuic.
    - constructor; eexists _, (decompose_stack π).1; eauto using whnf_red with pcuic.
    - eapply unfold_one_fix_None in H0 as [(?&?&?)].
      constructor; eexists _, x.
      split; [constructor; eauto with pcuic|].
      eauto with pcuic.
    - constructor; eexists _, (decompose_stack π).1.
      split; [constructor; eauto with pcuic|].
      eauto with pcuic.
    - constructor; eexists _, (decompose_stack π).1.
      split; [econstructor|]; eauto.
      split; [eauto with pcuic|].
      apply whnf_mkApps.
      eapply whne_const; eauto.
    - zip fold in h.
      apply wellformed_context in h; auto.
      destruct hΣ.
      apply wellformed_nonarity in h as (?&typ); auto.
      apply inversion_Const in typ as (?&?&?&?); auto.
      unfold declared_constant in d; congruence.
    - zip fold in h.
      apply wellformed_context in h; auto.
      destruct hΣ.
      apply wellformed_nonarity in h as (?&typ); auto.
      apply inversion_Const in typ as (?&?&?&?); auto.
      unfold declared_constant in d; congruence.
    - clear H.
      apply unfold_one_case_None in e as [(c'&r&whcase)].
      constructor; exists (tCase (i, n) p c' brs), (decompose_stack π).1.
      split.
      + constructor; eauto with pcuic.
      + split; [eauto with pcuic|].
        apply whnf_mkApps.
        auto.
    - clear H.
      apply unfold_one_proj_None in e as [(c'&r&whproj)].
      constructor; exists (tProj p0 c'), (decompose_stack π).1.
      split.
      + constructor; eauto with pcuic.
      + split; [eauto with pcuic|].
        apply whnf_mkApps.
        auto.
  Qed.
  
  (* TODO Factorise *)
  Equations(noeqns) _isconv_fallback (Γ : context) (leq : conv_pb)
            (t1 : term) (π1 : stack) (h1 : wtp Γ t1 π1)
            (t2 : term) (π2 : stack) (h2 : wtp Γ t2 π2)
            (ir1 : isred_full Γ t1 π1) (ir2 : isred_full Γ t2 π2)
            (hdiscr : prog_discr t1 t2)
            (hx : conv_stack_ctx Γ π1 π2)
            (aux : Aux Fallback Γ t1 π1 t2 π2 h2)
    : ConversionResult (conv_term leq Γ t1 π1 t2 π2) :=
    _isconv_fallback Γ leq t1 π1 h1 t2 π2 h2 ir1 ir2 hdiscr hx aux
    with inspect (reducible_head Γ t1 π1 h1) := {
    | @exist (Some (rt1, ρ1)) eq1 with inspect (decompose_stack ρ1) := {
      | @exist (l1, θ1) eq2
        with inspect (reduce_stack RedFlags.nodelta Σ hΣ (Γ ,,, stack_context ρ1) rt1 (appstack l1 ε) _) := {
        | @exist (rt1', θ1') eq3 :=
          isconv_prog leq rt1' (θ1' +++ θ1) t2 π2 aux
        }
      } ;
    | @exist None nored1 with inspect (reducible_head Γ t2 π2 h2) := {
      | @exist (Some (rt2, ρ2)) eq1 with inspect (decompose_stack ρ2) := {
        | @exist (l2, θ2) eq2
          with inspect (reduce_stack RedFlags.nodelta Σ hΣ (Γ ,,, stack_context ρ2) rt2 (appstack l2 ε) _) := {
          | @exist (rt2', θ2') eq3 :=
            isconv_prog leq t1 π1 rt2' (θ2' +++ θ2) aux
          }
        } ;
      | @exist None nored2 with inspect (eqb_termp_napp leq #|(decompose_stack π1).1| t1 t2) := {
        | @exist true eq1 := isconv_args leq t1 π1 t2 π2 aux;
        | @exist false noteq :=
          Error (
              HeadMismatch
                leq
                (Γ ,,, stack_context π1) t1
                (Γ ,,, stack_context π2) t2
            ) _
        }
      }
    }.
  Next Obligation.
    cbn. rewrite zipc_appstack. cbn.
    apply reducible_head_red_zipp in eq1 as r.
    apply reducible_head_decompose in eq1 as d.
    rewrite <- eq2 in d. simpl in d.
    unfold zipp in r.
    rewrite <- eq2 in r.
    case_eq (decompose_stack π1). intros l1' ρ1' e1.
    rewrite e1 in r.
    rewrite e1 in d. simpl in d. subst.
    apply wellformed_zipc_zipp in h1 as hh1. 2: auto.
    apply decompose_stack_eq in e1 as ?. subst.
    unfold zipp in hh1. rewrite e1 in hh1.
    pose proof (red_wellformed _ hΣ hh1 r) as hh.
    symmetry in eq2.
    apply decompose_stack_eq in eq2. subst.
    rewrite stack_context_appstack.
    rewrite stack_context_appstack in hh.
    assumption.
  Qed.
  Next Obligation.
    apply reducible_head_cored in eq1 as r1. apply cored_red in r1.
    destruct r1 as [r1].
    match type of eq3 with
    | _ = reduce_stack ?f ?Σ ?hΣ ?Γ ?t ?π ?h =>
      destruct (reduce_stack_sound f Σ hΣ Γ t π h) as [r2] ;
      pose proof (reduce_stack_decompose RedFlags.nodelta _ hΣ _ _ _ h) as d2
    end.
    rewrite <- eq3 in r2. cbn in r2.
    rewrite <- eq3 in d2. cbn in d2.
    rewrite decompose_stack_appstack in d2. cbn in d2.
    rewrite zipc_appstack in r2. cbn in r2.
    case_eq (decompose_stack θ1'). intros l s e.
    rewrite e in d2. cbn in d2. subst.
    apply decompose_stack_eq in e as ?. subst.
    rewrite stack_cat_appstack.
    rewrite zipc_appstack in r2. cbn in r2.
    rewrite zipc_appstack.
    pose proof (eq_sym eq2) as eq2'.
    apply decompose_stack_eq in eq2'. subst.
    rewrite stack_context_appstack in r2.
    eapply red_wellformed ; auto ; revgoals.
    - constructor. zip fold. eapply red_context. eassumption.
    - rewrite zipc_appstack in r1. cbn.
      eapply red_wellformed ; auto ; revgoals.
      + constructor. eassumption.
      + assumption.
  Qed.
  Next Obligation.
    eapply R_cored. simpl.
    apply reducible_head_cored in eq1 as r1.
    apply reducible_head_decompose in eq1 as d1.
    rewrite <- eq2 in d1. cbn in d1.
    case_eq (decompose_stack π1). intros l' s' e'.
    rewrite e' in d1. cbn in d1. subst.
    match type of eq3 with
    | _ = reduce_stack ?f ?Σ ?hΣ ?Γ ?t ?π ?h =>
      destruct (reduce_stack_sound f Σ hΣ Γ t π h) as [r2] ;
      pose proof (reduce_stack_decompose RedFlags.nodelta _ hΣ _ _ _ h) as d2
    end.
    rewrite <- eq3 in r2. cbn in r2.
    rewrite <- eq3 in d2. cbn in d2.
    rewrite decompose_stack_appstack in d2. cbn in d2.
    rewrite zipc_appstack in r2. cbn in r2.
    case_eq (decompose_stack θ1'). intros l s e.
    rewrite e in d2. cbn in d2. subst.
    apply decompose_stack_eq in e as ?. subst.
    apply decompose_stack_eq in e' as ?. subst.
    rewrite stack_cat_appstack. rewrite 2!zipc_appstack.
    rewrite zipc_appstack in r2. simpl in r2.
    clear eq3. symmetry in eq2. apply decompose_stack_eq in eq2. subst.
    rewrite 2!zipc_appstack in r1.
    rewrite stack_context_appstack in r2.
    eapply red_cored_cored ; try eassumption.
    repeat zip fold. eapply red_context. assumption.
  Qed.
  Next Obligation.
    apply reducible_head_decompose in eq1 as d1.
    rewrite <- eq2 in d1. cbn in d1.
    case_eq (decompose_stack π1). intros l' s' e'.
    rewrite e' in d1. cbn in d1. subst.
    match type of eq3 with
    | _ = reduce_stack ?f ?Σ ?hΣ ?Γ ?t ?π ?h =>
      pose proof (reduce_stack_decompose RedFlags.nodelta _ hΣ _ _ _ h) as d2
    end.
    rewrite <- eq3 in d2. cbn in d2.
    rewrite decompose_stack_appstack in d2. cbn in d2.
    case_eq (decompose_stack θ1'). intros l s e.
    rewrite e in d2. cbn in d2. subst.
    apply decompose_stack_eq in e as ?. subst.
    apply decompose_stack_eq in e' as ?. subst.
    rewrite stack_cat_appstack.
    rewrite stack_context_appstack.
    clear eq3.
    rewrite stack_context_appstack in hx.
    assumption.
  Qed.
  Next Obligation.
    match type of eq3 with
    | _ = reduce_stack ?f ?Σ ?hΣ ?Γ ?t ?π ?h =>
      pose proof (reduce_stack_isred RedFlags.nodelta _ hΣ _ _ _ h eq_refl) as ir;
      pose proof (reduce_stack_whnf RedFlags.nodelta _ hΣ _ _ _ h) as wh
    end.
    rewrite <- eq3 in ir, wh.
    destruct ir as (?&_).
    split; auto.
    rewrite stack_context_stack_cat.
    rewrite <- (stack_context_decompose ρ1) in wh.
    rewrite <- eq2 in wh.
    rewrite zipp_stack_cat; [rewrite app_context_assoc; auto|].
    eapply decompose_stack_noStackApp; eauto.
  Qed.
  Next Obligation.
    destruct hΣ as [wΣ].
    apply reducible_head_red_zipp in eq1 as r1. destruct r1 as [r1].
    apply reducible_head_decompose in eq1 as d1.
    rewrite <- eq2 in d1. cbn in d1.
    case_eq (decompose_stack π1). intros l' s' e'.
    rewrite e' in d1. cbn in d1. subst.
    match type of eq3 with
    | _ = reduce_stack ?f ?Σ ?hΣ ?Γ ?t ?π ?h =>
      destruct (reduce_stack_sound f Σ hΣ Γ t π h) as [r2] ;
      pose proof (reduce_stack_decompose RedFlags.nodelta _ hΣ _ _ _ h) as d2
    end.
    rewrite <- eq3 in r2. cbn in r2.
    rewrite <- eq3 in d2. cbn in d2.
    rewrite decompose_stack_appstack in d2. cbn in d2.
    rewrite zipc_appstack in r2. cbn in r2.
    case_eq (decompose_stack θ1'). intros l s e.
    rewrite e in d2. cbn in d2. subst.
    apply decompose_stack_eq in e as ?. subst.
    apply decompose_stack_eq in e' as ?. subst.
    rewrite stack_context_appstack.
    rewrite stack_cat_appstack in h.
    rewrite stack_context_appstack in h.
    etransitivity ; try eassumption.
    unfold zipp. rewrite e'.
    unfold zipp in r1. rewrite e' in r1. rewrite <- eq2 in r1.
    rewrite decompose_stack_appstack.
    erewrite decompose_stack_twice ; eauto. simpl.
    rewrite app_nil_r.
    eapply red_conv_cum_l ; try assumption.
    rewrite stack_context_appstack in r1.
    eapply red_trans ; try eassumption.
    clear eq3. symmetry in eq2. apply decompose_stack_eq in eq2. subst.
    rewrite stack_context_appstack in r2.
    rewrite zipc_appstack in r2. cbn in r2.
    assumption.
  Qed.
  Next Obligation.
    apply h; clear h.
    (* Contrapositive of previous case *)
    destruct hΣ as [wΣ].
    apply reducible_head_red_zipp in eq1 as r1. destruct r1 as [r1].
    apply reducible_head_decompose in eq1 as d1.
    rewrite <- eq2 in d1. cbn in d1.
    case_eq (decompose_stack π1). intros l' s' e'.
    rewrite e' in d1. cbn in d1. subst.
    match type of eq3 with
    | _ = reduce_stack ?f ?Σ ?hΣ ?Γ ?t ?π ?h =>
      destruct (reduce_stack_sound f Σ hΣ Γ t π h) as [r2] ;
      pose proof (reduce_stack_decompose RedFlags.nodelta _ hΣ _ _ _ h) as d2
    end.
    rewrite <- eq3 in r2. cbn in r2.
    rewrite <- eq3 in d2. cbn in d2.
    rewrite decompose_stack_appstack in d2. cbn in d2.
    rewrite zipc_appstack in r2. cbn in r2.
    case_eq (decompose_stack θ1'). intros l s e.
    rewrite e in d2. cbn in d2. subst.
    apply decompose_stack_eq in e as ?. subst.
    apply decompose_stack_eq in e' as ?. subst.
    rewrite stack_context_appstack in H.
    rewrite stack_cat_appstack.
    rewrite stack_context_appstack.
    etransitivity ; try eassumption.
    unfold zipp. rewrite e'.
    unfold zipp in r1. rewrite e' in r1. rewrite <- eq2 in r1.
    rewrite decompose_stack_appstack.
    erewrite decompose_stack_twice ; eauto. simpl.
    rewrite app_nil_r.
    eapply red_conv_cum_r ; try assumption.
    rewrite stack_context_appstack in r1.
    eapply red_trans ; try eassumption.
    clear eq3. symmetry in eq2. apply decompose_stack_eq in eq2. subst.
    rewrite stack_context_appstack in r2.
    rewrite zipc_appstack in r2. cbn in r2.
    assumption.
  Qed.
  Next Obligation.
    cbn. rewrite zipc_appstack. cbn.
    apply reducible_head_red_zipp in eq1 as r.
    apply reducible_head_decompose in eq1 as d.
    rewrite <- eq2 in d.
    unfold zipp in r.
    rewrite <- eq2 in r.
    case_eq (decompose_stack π2). intros l2' ρ2' e2.
    rewrite e2 in r.
    rewrite e2 in d. simpl in d. subst.
    apply wellformed_zipc_zipp in h2 as hh2. 2: auto.
    apply decompose_stack_eq in e2 as ?. subst.
    unfold zipp in hh2. rewrite e2 in hh2.
    pose proof (red_wellformed _ hΣ hh2 r) as hh.
    symmetry in eq2.
    apply decompose_stack_eq in eq2. subst.
    rewrite stack_context_appstack.
    rewrite stack_context_appstack in hh.
    assumption.
  Qed.
  Next Obligation.
    apply reducible_head_cored in eq1 as r1. apply cored_red in r1.
    destruct r1 as [r1].
    match type of eq3 with
    | _ = reduce_stack ?f ?Σ ?hΣ ?Γ ?t ?π ?h =>
      destruct (reduce_stack_sound f Σ hΣ Γ t π h) as [r2] ;
      pose proof (reduce_stack_decompose RedFlags.nodelta _ hΣ _ _ _ h) as d2
    end.
    rewrite <- eq3 in r2. cbn in r2.
    rewrite <- eq3 in d2. cbn in d2.
    rewrite decompose_stack_appstack in d2. cbn in d2.
    rewrite zipc_appstack in r2. cbn in r2.
    case_eq (decompose_stack θ2'). intros l s e.
    rewrite e in d2. cbn in d2. subst.
    apply decompose_stack_eq in e as ?. subst.
    rewrite stack_cat_appstack.
    rewrite zipc_appstack in r2. cbn in r2.
    rewrite zipc_appstack.
    pose proof (eq_sym eq2) as eq2'.
    apply decompose_stack_eq in eq2'. subst.
    rewrite stack_context_appstack in r2.
    eapply red_wellformed ; auto ; revgoals.
    - constructor. zip fold. eapply red_context. eassumption.
    - rewrite zipc_appstack in r1. cbn.
      eapply red_wellformed ; auto ; revgoals.
      + constructor. eassumption.
      + assumption.
  Qed.
  Next Obligation.
    eapply R_cored2. all: simpl. all: try reflexivity.
    apply reducible_head_cored in eq1 as r1.
    apply reducible_head_decompose in eq1 as d1.
    rewrite <- eq2 in d1. cbn in d1.
    case_eq (decompose_stack π2). intros l' s' e'.
    rewrite e' in d1. cbn in d1. subst.
    match type of eq3 with
    | _ = reduce_stack ?f ?Σ ?hΣ ?Γ ?t ?π ?h =>
      destruct (reduce_stack_sound f Σ hΣ Γ t π h) as [r2] ;
      pose proof (reduce_stack_decompose RedFlags.nodelta _ hΣ _ _ _ h) as d2
    end.
    rewrite <- eq3 in r2. cbn in r2.
    rewrite <- eq3 in d2. cbn in d2.
    rewrite decompose_stack_appstack in d2. cbn in d2.
    rewrite zipc_appstack in r2. cbn in r2.
    case_eq (decompose_stack θ2'). intros l s e.
    rewrite e in d2. cbn in d2. subst.
    apply decompose_stack_eq in e as ?. subst.
    apply decompose_stack_eq in e' as ?. subst.
    rewrite stack_cat_appstack. rewrite 2!zipc_appstack.
    rewrite zipc_appstack in r2. simpl in r2.
    clear eq3. symmetry in eq2. apply decompose_stack_eq in eq2. subst.
    rewrite 2!zipc_appstack in r1.
    rewrite stack_context_appstack in r2.
    eapply red_cored_cored ; try eassumption.
    repeat zip fold. eapply red_context. assumption.
  Qed.
  Next Obligation.
    apply reducible_head_decompose in eq1 as d1.
    rewrite <- eq2 in d1. cbn in d1.
    case_eq (decompose_stack π2). intros l' s' e'.
    rewrite e' in d1. cbn in d1. subst.
    match type of eq3 with
    | _ = reduce_stack ?f ?Σ ?hΣ ?Γ ?t ?π ?h =>
      pose proof (reduce_stack_decompose RedFlags.nodelta _ hΣ _ _ _ h) as d2
    end.
    rewrite <- eq3 in d2. cbn in d2.
    rewrite decompose_stack_appstack in d2. cbn in d2.
    case_eq (decompose_stack θ2'). intros l s e.
    rewrite e in d2. cbn in d2. subst.
    apply decompose_stack_eq in e as ?. subst.
    apply decompose_stack_eq in e' as ?. subst.
    rewrite stack_cat_appstack.
    rewrite stack_context_appstack.
    clear eq3.
    rewrite stack_context_appstack in hx.
    assumption.
  Qed.
  Next Obligation.
    match type of eq3 with
    | _ = reduce_stack ?f ?Σ ?hΣ ?Γ ?t ?π ?h =>
      pose proof (reduce_stack_isred RedFlags.nodelta _ hΣ _ _ _ h eq_refl) as ir;
      pose proof (reduce_stack_whnf RedFlags.nodelta _ hΣ _ _ _ h) as wh
    end.
    rewrite <- eq3 in ir, wh.
    destruct ir as (?&_).
    split; auto.
    rewrite stack_context_stack_cat.
    rewrite <- (stack_context_decompose ρ2) in wh.
    rewrite <- eq2 in wh.
    rewrite zipp_stack_cat; [rewrite app_context_assoc; auto|].
    eapply decompose_stack_noStackApp; eauto.
  Qed.
  Next Obligation.
    destruct hΣ as [wΣ].
    apply reducible_head_red_zipp in eq1 as r1. destruct r1 as [r1].
    apply reducible_head_decompose in eq1 as d1.
    rewrite <- eq2 in d1. cbn in d1.
    case_eq (decompose_stack π2). intros l' s' e'.
    rewrite e' in d1. cbn in d1. subst.
    match type of eq3 with
    | _ = reduce_stack ?f ?Σ ?hΣ ?Γ ?t ?π ?h =>
      destruct (reduce_stack_sound f Σ hΣ Γ t π h) as [r2] ;
      pose proof (reduce_stack_decompose RedFlags.nodelta _ hΣ _ _ _ h) as d2
    end.
    rewrite <- eq3 in r2. cbn in r2.
    rewrite <- eq3 in d2. cbn in d2.
    rewrite decompose_stack_appstack in d2. cbn in d2.
    rewrite zipc_appstack in r2. cbn in r2.
    case_eq (decompose_stack θ2'). intros l s e.
    rewrite e in d2. cbn in d2. subst.
    unfold zipp. rewrite e'.
    unfold zipp in r1. rewrite e' in r1. rewrite <- eq2 in r1.
    apply decompose_stack_eq in e as ?. subst.
    apply decompose_stack_eq in e' as ?. subst.
    clear eq3.
    rewrite stack_context_appstack in hx.
    destruct hx as [hx].
    etransitivity ; try eassumption.
    unfold zipp.
    rewrite stack_cat_appstack.
    rewrite decompose_stack_appstack.
    erewrite decompose_stack_twice ; eauto. simpl.
    rewrite app_nil_r.
    eapply conv_cum_context_convp.
    - assumption.
    - eapply red_conv_cum_r. 1: assumption.
      rewrite stack_context_appstack in r1.
      eapply red_trans ; try eassumption.
      symmetry in eq2. apply decompose_stack_eq in eq2. subst.
      rewrite stack_context_appstack in r2.
      rewrite zipc_appstack in r2. cbn in r2.
      assumption.
    - eapply conv_context_sym. all: auto.
  Qed.
  Next Obligation.
    apply h; clear h.
    (* Contrapositive of previous case *)
    destruct hΣ as [wΣ].
    apply reducible_head_red_zipp in eq1 as r1. destruct r1 as [r1].
    apply reducible_head_decompose in eq1 as d1.
    rewrite <- eq2 in d1. cbn in d1.
    case_eq (decompose_stack π2). intros l' s' e'.
    rewrite e' in d1. cbn in d1. subst.
    match type of eq3 with
    | _ = reduce_stack ?f ?Σ ?hΣ ?Γ ?t ?π ?h =>
      destruct (reduce_stack_sound f Σ hΣ Γ t π h) as [r2] ;
      pose proof (reduce_stack_decompose RedFlags.nodelta _ hΣ _ _ _ h) as d2
    end.
    rewrite <- eq3 in r2. cbn in r2.
    rewrite <- eq3 in d2. cbn in d2.
    rewrite decompose_stack_appstack in d2. cbn in d2.
    rewrite zipc_appstack in r2. cbn in r2.
    case_eq (decompose_stack θ2'). intros l s e.
    rewrite e in d2. cbn in d2. subst.
    unfold zipp in r1. rewrite e' in r1.
    unfold zipp in H. rewrite e' in H. rewrite <- eq2 in r1.
    apply decompose_stack_eq in e as ?. subst.
    apply decompose_stack_eq in e' as ?. subst.
    clear eq3.
    rewrite stack_context_appstack in hx.
    destruct hx as [hx].
    etransitivity ; try eassumption.
    unfold zipp.
    rewrite stack_cat_appstack.
    rewrite decompose_stack_appstack.
    erewrite decompose_stack_twice ; eauto. simpl.
    rewrite app_nil_r.
    eapply conv_cum_context_convp.
    - assumption.
    - eapply red_conv_cum_l.
      rewrite stack_context_appstack in r1.
      eapply red_trans ; try eassumption.
      symmetry in eq2. apply decompose_stack_eq in eq2. subst.
      rewrite stack_context_appstack in r2.
      rewrite zipc_appstack in r2. cbn in r2.
      assumption.
    - eapply conv_context_sym. all: auto.
  Qed.
  Next Obligation.
    eapply R_stateR. all: simpl. all: try reflexivity.
    constructor.
  Qed.
  Next Obligation.
    destruct h, hΣ.
    apply conv_terms_alt in X as (argsr&argsr'&?&?&?).
    rewrite !zipp_as_mkApps.
    apply conv_cum_alt.
    constructor; eexists _, _.
    split; [split|].
    - apply red_mkApps; [reflexivity|eassumption].
    - apply red_mkApps; [reflexivity|eassumption].
    - apply eq_term_upto_univ_napp_mkApps; auto.
      rewrite Nat.add_0_r.
      apply All2_length in a.
      rewrite a in eq1.
      apply eqb_termp_napp_spec; eauto.
  Qed.
  Next Obligation.
    apply h; clear h.
    destruct ir1 as (notapp1&whδ1), ir2 as (notapp2&whδ2).
    rewrite !zipp_as_mkApps in *.
    apply reducible_head_None in nored1 as [(?&?&s1&r1&wh1)]; auto.
    apply reducible_head_None in nored2 as [(?&?&s2&r2&wh2)]; auto.
    destruct hΣ, hx.
    apply whnf_red_red in s1 as H'.
    destruct H'.
    apply whnf_red_red in s2 as H'.
    destruct H'.
    eapply conv_cum_red_inv' in H.
    2: exact hΣ'.
    2: eassumption.
    2: apply red_mkApps; [eassumption|eassumption].
    2: apply red_mkApps; [eassumption|eassumption].
    apply conv_cum_mkApps_inv in H as [(?&?)]; auto.
    2: now depelim s1.
    2: now depelim s2.
    2: eapply whnf_conv_context; eauto.
    2: eapply conv_context_sym; eauto.
    constructor.
    eapply conv_terms_red'; eauto.
  Qed.

  Next Obligation.
    unfold eqb_termp_napp in noteq.
    destruct ir1 as (notapp1&whδ1), ir2 as (notapp2&whδ2).
    rewrite !zipp_as_mkApps in *.
    apply reducible_head_None in nored1 as [(?&?&s1&rargs1&wh1)]; auto.
    apply reducible_head_None in nored2 as [(?&?&s2&rargs2&wh2)]; auto.
    destruct hΣ, hx.
    apply whnf_red_red in s1 as H'.
    destruct H'.
    apply whnf_red_red in s2 as H'.
    destruct H'.
    eapply conv_cum_red_inv' in H.
    2: exact hΣ'.
    2: eassumption.
    2: apply red_mkApps; eassumption.
    2: apply red_mkApps; eassumption.
    apply conv_cum_mkApps_inv in H as [(conv_hds&_)]; auto.
    2: now depelim s1.
    2: now depelim s2.
    2: eapply whnf_conv_context; eauto.
    2: eapply conv_context_sym; eauto.
    apply whnf_mkApps_inv in wh1; [|now depelim s1].
    destruct t1; cbn in *.
    all: depelim s1.
    9: { destruct conv_hds as [H].
         depelim H.
         depelim s2.
         zip fold in h1.
         zip fold in h2.
         apply wellformed_context in h1; auto.
         clear aux.
         apply wellformed_context in h2; auto.
         apply wellformed_nonarity in h1 as (?&typ1); auto.
         apply wellformed_nonarity in h2 as (?&typ2); auto.
         apply inversion_Ind in typ1 as (?&?&?&?&?&?); auto.
         apply inversion_Ind in typ2 as (?&?&?&?&?&?); auto.
         apply consistent_instance_ext_all_mem in c1.
         apply consistent_instance_ext_all_mem in c.
         apply R_global_instance_spec in r; auto.
         rewrite eq_inductive_refl in noteq.
         apply All2_length in rargs1.
         rewrite <- rargs1 in r.
         cbn in *.
         easy. }
    9: { destruct conv_hds as [H].
         depelim H.
         depelim s2.
         zip fold in h1.
         zip fold in h2.
         apply wellformed_context in h1; auto.
         clear aux.
         apply wellformed_context in h2; auto.
         apply wellformed_nonarity in h1 as (?&typ1); auto.
         apply wellformed_nonarity in h2 as (?&typ2); auto.
         apply inversion_Construct in typ1 as (?&?&?&?&?&?&?); auto.
         apply inversion_Construct in typ2 as (?&?&?&?&?&?&?); auto.
         apply consistent_instance_ext_all_mem in c1.
         apply consistent_instance_ext_all_mem in c.
         apply R_global_instance_spec in r; auto.
         rewrite eq_inductive_refl, Nat.eqb_refl in noteq.
         apply All2_length in rargs1.
         rewrite <- rargs1 in r.
         cbn in *.
         easy. }
    all: apply conv_cum_alt in conv_hds as [(?&?&(r1&r2)&?)].
    all: eapply whnf_red_inv in r1; auto.
    all: inversion r1; subst; clear r1.
    all: inversion e; subst; clear e.
    all: apply whnf_mkApps_inv in wh2; [|now depelim s2].
    all: eapply whnf_conv_context in wh2; [|apply conv_context_sym; eauto].
    all: eapply whnf_red_inv in r2; auto.
    all: inversion r2; subst; clear r2.
    all: inversion s2; subst; clear s2.
    all: destruct hdiscr.
    - now rewrite Nat.eqb_refl in noteq.
    - now rewrite eq_string_refl in noteq.
    - zip fold in h1.
      apply wellformed_context in h1; auto.
      destruct h1 as [(?&typ)|[(?&?&?&?)]].
      + now apply inversion_Evar in typ.
      + cbn in e; congruence.
    - zip fold in h1.
      zip fold in h2.
      apply wellformed_context in h1; auto.
      clear aux.
      apply wellformed_context in h2; auto.
      eapply conv_pb_rel_spec in H0.
      assert (forall Σ Γ s, wellformed Σ Γ (tSort s) ->
                            Forall (fun s => LevelSet.In s (global_ext_levels Σ)) s).
      destruct h1 as [(?&typ)|].
      + apply inversion_Sort in typ as (?&?&?&?&?); auto.
        apply conv_pb_rel_spec in H0:
        admit.
      + destruct H as [(?&?&?&?)].
        cbn in *.
      apply conv_pb_rel_spec in H0.
  Qed.
  
  Equations _isconv (s : state) (Γ : context)
            (t1 : term) (π1 : stack) (h1 : wtp Γ t1 π1)
            (t2 : term) (π2 : stack) (h2 : wtp Γ t2 π2)
            (aux : Aux s Γ t1 π1 t2 π2 h2)
  : Ret s Γ t1 π1 t2 π2 :=
    _isconv Reduction Γ t1 π1 h1 t2 π2 h2 aux :=
      λ { | leq | hx | _ | _ | _ := _isconv_red Γ leq t1 π1 h1 t2 π2 h2 hx aux } ;

    _isconv Term Γ t1 π1 h1 t2 π2 h2 aux :=
      λ { | leq | hx | r1 | r2 | _ := _isconv_prog Γ leq t1 π1 h1 t2 π2 h2 hx r1 r2 aux } ;

    _isconv Args Γ t1 π1 h1 t2 π2 h2 aux :=
      λ { | leq | hx | _ | _ | _ := _isconv_args leq Γ t1 π1 h1 t2 π2 h2 hx aux } ;

    _isconv Fallback Γ t1 π1 h1 t2 π2 h2 aux :=
      λ { | leq | hx | r1 | r2 | hd := _isconv_fallback Γ leq t1 π1 h1 t2 π2 h2 r1 r2 hd hx aux }.

  Equations(noeqns) isconv_full (s : state) (Γ : context)
            (t1 : term) (π1 : stack) (h1 : wtp Γ t1 π1)
            (t2 : term) (π2 : stack) (h2 : wtp Γ t2 π2)
    : Ret s Γ t1 π1 t2 π2 :=

    isconv_full s Γ t1 π1 h1 t2 π2 h2 hx :=
      Fix_F (R := R Γ)
            (fun '(mkpack s' t1' π1' t2' π2' h2') =>
              wtp Γ t1' π1' ->
              wtp Γ t2' π2' ->
              Ret s' Γ t1' π1' t2' π2'
            )
            (fun pp f => _)
            (x := mkpack Γ s t1 π1 t2 π2 _)
            _ _ _ _.
  Next Obligation.
    unshelve eapply _isconv. all: try assumption.
    intros s' t1' π1' t2' π2' h1' h2' hx' hR.
    apply wellformed_zipc_zipp in h1. 2: auto.
    destruct pp.
    assert (wth0 = H0) by apply wellformed_irr. subst.
    specialize (f (mkpack Γ s' t1' π1' t2' π2' h2') hR). cbn in f.
    eapply f ; assumption.
  Qed.
  Next Obligation.
    apply R_Acc. assumption.
  Qed.
  
  Inductive ConversionResultSummary :=
  | ConvSuccess : ConversionResultSummary
  | ConvError : ConversionError -> ConversionResultSummary.

  Definition isconv Γ leq t1 π1 h1 t2 π2 h2 hx :=
    match isconv_full Reduction Γ t1 π1 h1 t2 π2 h2 leq hx I I I with
    | Success _ => ConvSuccess
    | Error e _ => ConvError e
    end.
  
  Theorem isconv_sound :
    forall Γ leq t1 π1 h1 t2 π2 h2 hx,
      isconv Γ leq t1 π1 h1 t2 π2 h2 hx = ConvSuccess ->
      conv_cum leq Σ (Γ ,,, stack_context π1) (zipp t1 π1) (zipp t2 π2).
  Proof.
    unfold isconv.
    intros Γ leq t1 π1 h1 t2 π2 h2 hx.
    destruct isconv_full as [].
    - auto.
    - discriminate.
  Qed.
  
  Theorem isconv_complete :
    forall Γ leq t1 π1 h1 t2 π2 h2 hx e,
      isconv Γ leq t1 π1 h1 t2 π2 h2 hx = ConvError e ->
      ~conv_cum leq Σ (Γ ,,, stack_context π1) (zipp t1 π1) (zipp t2 π2).
  Proof.
    unfold isconv.
    intros Γ leq t1 π1 h1 t2 π2 h2 hx.
    destruct isconv_full as []; auto.
    intros ? [=].
  Qed.

  Definition isconv_term Γ leq t1 (h1 : wellformed Σ Γ t1) t2 (h2 : wellformed Σ Γ t2) :=
    isconv Γ leq t1 ε h1 t2 ε h2 (sq (conv_ctx_refl _ Γ)).

  Theorem isconv_term_sound :
    forall Γ leq t1 h1 t2 h2,
      isconv_term Γ leq t1 h1 t2 h2 = ConvSuccess ->
      conv_cum leq Σ Γ t1 t2.
  Proof.
    intros Γ leq t1 h1 t2 h2.
    unfold isconv_term. intro h.
    apply isconv_sound in h. apply h.
  Qed.

  Theorem isconv_term_complete :
    forall Γ leq t1 h1 t2 h2 e,
      isconv_term Γ leq t1 h1 t2 h2 = ConvError e ->
      ~conv_cum leq Σ Γ t1 t2.
  Proof.
    intros Γ leq t1 h1 t2 h2 e.
    unfold isconv_term. intro h.
    apply isconv_complete in h. apply h.
  Qed.
  Transparent reduce_stack.

End Conversion.
